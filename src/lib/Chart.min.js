function fontString(t, e, i) {
  return e + ' ' + t + 'px ' + i;
}
const requestAnimFrame =
  'undefined' == typeof window
    ? function (t) {
        return t();
      }
    : window.requestAnimationFrame;
function drawFPS(t, e, i, n) {
  const o = (1e3 / (i - n)) | 0,
    a = t.ctx;
  a.save(),
    a.clearRect(0, 0, 50, 24),
    (a.fillStyle = 'black'),
    (a.textAlign = 'right'),
    e && (a.fillText(e, 50, 8), a.fillText(o + ' fps', 50, 18)),
    a.restore();
}
class Animator {
  constructor() {
    (this._request = null),
      (this._charts = new Map()),
      (this._running = !1),
      (this._lastDate = void 0);
  }
  _notify(t, e, i, n) {
    const o = e.listeners[n] || [],
      a = e.duration;
    o.forEach((n) => n({ chart: t, numSteps: a, currentStep: i - e.start }));
  }
  _refresh() {
    const t = this;
    t._request ||
      ((t._running = !0),
      (t._request = requestAnimFrame.call(window, () => {
        t._update(), (t._request = null), t._running && t._refresh();
      })));
  }
  _update() {
    const t = this,
      e = Date.now();
    let i = 0;
    t._charts.forEach((n, o) => {
      if (!n.running || !n.items.length) return;
      const a = n.items;
      let r,
        s = a.length - 1,
        l = !1;
      for (; s >= 0; --s)
        (r = a[s])._active
          ? (r.tick(e), (l = !0))
          : ((a[s] = a[a.length - 1]), a.pop());
      l && o.draw(),
        o.options.animation.debug && drawFPS(o, a.length, e, t._lastDate),
        t._notify(o, n, e, 'progress'),
        a.length || ((n.running = !1), t._notify(o, n, e, 'complete')),
        (i += a.length);
    }),
      (t._lastDate = e),
      0 === i && (t._running = !1);
  }
  _getAnims(t) {
    const e = this._charts;
    let i = e.get(t);
    return (
      i ||
        ((i = {
          running: !1,
          items: [],
          listeners: { complete: [], progress: [] },
        }),
        e.set(t, i)),
      i
    );
  }
  listen(t, e, i) {
    this._getAnims(t).listeners[e].push(i);
  }
  add(t, e) {
    e && e.length && this._getAnims(t).items.push(...e);
  }
  has(t) {
    return this._getAnims(t).items.length > 0;
  }
  start(t) {
    const e = this._charts.get(t);
    e &&
      ((e.running = !0),
      (e.start = Date.now()),
      (e.duration = e.items.reduce((t, e) => Math.max(t, e._duration), 0)),
      this._refresh());
  }
  running(t) {
    if (!this._running) return !1;
    const e = this._charts.get(t);
    return !!(e && e.running && e.items.length);
  }
  stop(t) {
    const e = this._charts.get(t);
    if (!e || !e.items.length) return;
    const i = e.items;
    let n = i.length - 1;
    for (; n >= 0; --n) i[n].cancel();
    (e.items = []), this._notify(t, e, Date.now(), 'complete');
  }
  remove(t) {
    return this._charts.delete(t);
  }
}
var animator = new Animator();
const effects = {
  linear: (t) => t,
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => -t * (t - 2),
  easeInOutQuad: (t) =>
    (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => (t -= 1) * t * t + 1,
  easeInOutCubic: (t) =>
    (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
  easeInOutQuart: (t) =>
    (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
  easeInOutQuint: (t) =>
    (t /= 0.5) < 1
      ? 0.5 * t * t * t * t * t
      : 0.5 * ((t -= 2) * t * t * t * t + 2),
  easeInSine: (t) => 1 - Math.cos(t * (Math.PI / 2)),
  easeOutSine: (t) => Math.sin(t * (Math.PI / 2)),
  easeInOutSine: (t) => -0.5 * (Math.cos(Math.PI * t) - 1),
  easeInExpo: (t) => (0 === t ? 0 : Math.pow(2, 10 * (t - 1))),
  easeOutExpo: (t) => (1 === t ? 1 : 1 - Math.pow(2, -10 * t)),
  easeInOutExpo: (t) =>
    0 === t
      ? 0
      : 1 === t
      ? 1
      : (t /= 0.5) < 1
      ? 0.5 * Math.pow(2, 10 * (t - 1))
      : 0.5 * (2 - Math.pow(2, -10 * --t)),
  easeInCirc: (t) => (t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1)),
  easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
  easeInOutCirc: (t) =>
    (t /= 0.5) < 1
      ? -0.5 * (Math.sqrt(1 - t * t) - 1)
      : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeInElastic(t) {
    let e = 1.70158,
      i = 0;
    return 0 === t
      ? 0
      : 1 === t
      ? 1
      : (i || (i = 0.3),
        (e = (i / (2 * Math.PI)) * Math.asin(1)),
        -1 *
          Math.pow(2, 10 * (t -= 1)) *
          Math.sin(((t - e) * (2 * Math.PI)) / i));
  },
  easeOutElastic(t) {
    let e = 1.70158,
      i = 0;
    return 0 === t
      ? 0
      : 1 === t
      ? 1
      : (i || (i = 0.3),
        (e = (i / (2 * Math.PI)) * Math.asin(1)),
        1 * Math.pow(2, -10 * t) * Math.sin(((t - e) * (2 * Math.PI)) / i) + 1);
  },
  easeInOutElastic(t) {
    let e = 1.70158,
      i = 0;
    return 0 === t
      ? 0
      : 2 == (t /= 0.5)
      ? 1
      : (i || (i = 0.45),
        (e = (i / (2 * Math.PI)) * Math.asin(1)),
        t < 1
          ? 1 *
            Math.pow(2, 10 * (t -= 1)) *
            Math.sin(((t - e) * (2 * Math.PI)) / i) *
            -0.5
          : 1 *
              Math.pow(2, -10 * (t -= 1)) *
              Math.sin(((t - e) * (2 * Math.PI)) / i) *
              0.5 +
            1);
  },
  easeInBack(t) {
    const e = 1.70158;
    return t * t * ((e + 1) * t - e);
  },
  easeOutBack(t) {
    const e = 1.70158;
    return (t -= 1) * t * ((e + 1) * t + e) + 1;
  },
  easeInOutBack(t) {
    let e = 1.70158;
    return (t /= 0.5) < 1
      ? t * t * ((1 + (e *= 1.525)) * t - e) * 0.5
      : 0.5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2);
  },
  easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
  easeOutBounce: (t) =>
    t < 1 / 2.75
      ? 7.5625 * t * t
      : t < 2 / 2.75
      ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75
      : t < 2.5 / 2.75
      ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375
      : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375,
  easeInOutBounce: (t) =>
    t < 0.5
      ? 0.5 * effects.easeInBounce(2 * t)
      : 0.5 * effects.easeOutBounce(2 * t - 1) + 0.5,
};
function noop() {}
const uid = (function () {
  let t = 0;
  return function () {
    return t++;
  };
})();
function isNullOrUndef(t) {
  return null == t;
}
function isArray(t) {
  if (Array.isArray && Array.isArray(t)) return !0;
  const e = Object.prototype.toString.call(t);
  return '[object' === e.substr(0, 7) && 'Array]' === e.substr(-6);
}
function isObject(t) {
  return null !== t && '[object Object]' === Object.prototype.toString.call(t);
}
const isNumberFinite = (t) =>
  ('number' == typeof t || t instanceof Number) && isFinite(+t);
function valueOrDefault(t, e) {
  return void 0 === t ? e : t;
}
function callback(t, e, i) {
  if (t && 'function' == typeof t.call) return t.apply(i, e);
}
function each(t, e, i, n) {
  let o, a, r;
  if (isArray(t))
    if (((a = t.length), n)) for (o = a - 1; o >= 0; o--) e.call(i, t[o], o);
    else for (o = 0; o < a; o++) e.call(i, t[o], o);
  else if (isObject(t))
    for (a = (r = Object.keys(t)).length, o = 0; o < a; o++)
      e.call(i, t[r[o]], r[o]);
}
function _elementsEqual(t, e) {
  let i, n, o, a;
  if (!t || !e || t.length !== e.length) return !1;
  for (i = 0, n = t.length; i < n; ++i)
    if (
      ((o = t[i]),
      (a = e[i]),
      o.datasetIndex !== a.datasetIndex || o.index !== a.index)
    )
      return !1;
  return !0;
}
function clone(t) {
  if (isArray(t)) return t.map(clone);
  if (isObject(t)) {
    const e = Object.create(t),
      i = Object.keys(t),
      n = i.length;
    let o = 0;
    for (; o < n; ++o) e[i[o]] = clone(t[i[o]]);
    return e;
  }
  return t;
}
function _merger(t, e, i, n) {
  const o = e[t],
    a = i[t];
  isObject(o) && isObject(a) ? merge(o, a, n) : (e[t] = clone(a));
}
function merge(t, e, i) {
  const n = isArray(e) ? e : [e],
    o = n.length;
  if (!isObject(t)) return t;
  const a = (i = i || {}).merger || _merger;
  for (let r = 0; r < o; ++r) {
    if (!isObject((e = n[r]))) continue;
    const o = Object.keys(e);
    for (let n = 0, r = o.length; n < r; ++n) a(o[n], t, e, i);
  }
  return t;
}
function mergeIf(t, e) {
  return merge(t, e, { merger: _mergerIf });
}
function _mergerIf(t, e, i) {
  const n = e[t],
    o = i[t];
  isObject(n) && isObject(o)
    ? mergeIf(n, o)
    : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = clone(o));
}
function _deprecated(t, e, i, n) {
  void 0 !== e &&
    console.warn(
      t + ': "' + i + '" is deprecated. Please use "' + n + '" instead',
    );
}
var coreHelpers = Object.freeze({
  __proto__: null,
  noop: noop,
  uid: uid,
  isNullOrUndef: isNullOrUndef,
  isArray: isArray,
  isObject: isObject,
  isFinite: isNumberFinite,
  valueOrDefault: valueOrDefault,
  callback: callback,
  each: each,
  _elementsEqual: _elementsEqual,
  clone: clone,
  _merger: _merger,
  merge: merge,
  mergeIf: mergeIf,
  _mergerIf: _mergerIf,
  _deprecated: _deprecated,
});
function getScope(t, e) {
  if (!e) return t;
  const i = e.split('.');
  for (let e = 0, n = i.length; e < n; ++e) {
    const n = i[e];
    t = t[n] || (t[n] = {});
  }
  return t;
}
class Defaults {
  constructor() {
    (this.color = 'rgba(0,0,0,0.1)'),
      (this.elements = {}),
      (this.events = [
        'mousemove',
        'mouseout',
        'click',
        'touchstart',
        'touchmove',
      ]),
      (this.font = {
        color: '#666',
        family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
        size: 12,
        style: 'normal',
        lineHeight: 1.2,
        weight: null,
        lineWidth: 0,
        strokeStyle: void 0,
      }),
      (this.hover = { onHover: null, mode: 'nearest', intersect: !0 }),
      (this.maintainAspectRatio = !0),
      (this.onClick = null),
      (this.responsive = !0),
      (this.showLines = !0),
      (this.plugins = void 0),
      (this.scale = void 0),
      (this.legend = void 0),
      (this.title = void 0),
      (this.tooltips = void 0),
      (this.doughnut = void 0),
      (this._routes = {});
  }
  set(t, e) {
    return merge(getScope(this, t), e);
  }
  route(t, e, i, n) {
    const o = getScope(this, t),
      a = getScope(this, i),
      r = isArray(n);
    e.forEach((t, e) => {
      const i = '_' + t,
        s = r ? n[e] : n;
      Object.defineProperties(o, {
        [i]: { writable: !0 },
        [t]: {
          enumerable: !0,
          get() {
            return valueOrDefault(this[i], a[s]);
          },
          set(t) {
            this[i] = t;
          },
        },
      });
    });
  }
}
var defaults = new Defaults();
const PI = Math.PI,
  RAD_PER_DEG = PI / 180,
  DOUBLE_PI = 2 * PI,
  HALF_PI = PI / 2,
  QUARTER_PI = PI / 4,
  TWO_THIRDS_PI = (2 * PI) / 3;
function toFontString(t) {
  return !t || isNullOrUndef(t.size) || isNullOrUndef(t.family)
    ? null
    : (t.style ? t.style + ' ' : '') +
        (t.weight ? t.weight + ' ' : '') +
        t.size +
        'px ' +
        t.family;
}
function _measureText(t, e, i, n, o) {
  let a = e[o];
  return (
    a || ((a = e[o] = t.measureText(o).width), i.push(o)), a > n && (n = a), n
  );
}
function _longestText(t, e, i, n) {
  let o = ((n = n || {}).data = n.data || {}),
    a = (n.garbageCollect = n.garbageCollect || []);
  n.font !== e &&
    ((o = n.data = {}), (a = n.garbageCollect = []), (n.font = e)),
    t.save(),
    (t.font = e);
  let r = 0;
  const s = i.length;
  let l, c, d, h, u;
  for (l = 0; l < s; l++)
    if (null != (h = i[l]) && !0 !== isArray(h))
      r = _measureText(t, o, a, r, h);
    else if (isArray(h))
      for (c = 0, d = h.length; c < d; c++)
        null == (u = h[c]) || isArray(u) || (r = _measureText(t, o, a, r, u));
  t.restore();
  const g = a.length / 2;
  if (g > i.length) {
    for (l = 0; l < g; l++) delete o[a[l]];
    a.splice(0, g);
  }
  return r;
}
function _alignPixel(t, e, i) {
  const n = t.currentDevicePixelRatio,
    o = i / 2;
  return Math.round((e - o) * n) / n + o;
}
function clear(t) {
  t.ctx.clearRect(0, 0, t.width, t.height);
}
function drawPoint(t, e, i, n) {
  let o, a, r, s, l;
  const c = e.pointStyle,
    d = e.rotation,
    h = e.radius;
  let u = (d || 0) * RAD_PER_DEG;
  if (
    c &&
    'object' == typeof c &&
    ('[object HTMLImageElement]' === (o = c.toString()) ||
      '[object HTMLCanvasElement]' === o)
  )
    return (
      t.save(),
      t.translate(i, n),
      t.rotate(u),
      t.drawImage(c, -c.width / 2, -c.height / 2, c.width, c.height),
      void t.restore()
    );
  if (!(isNaN(h) || h <= 0)) {
    switch ((t.beginPath(), c)) {
      default:
        t.arc(i, n, h, 0, DOUBLE_PI), t.closePath();
        break;
      case 'triangle':
        t.moveTo(i + Math.sin(u) * h, n - Math.cos(u) * h),
          (u += TWO_THIRDS_PI),
          t.lineTo(i + Math.sin(u) * h, n - Math.cos(u) * h),
          (u += TWO_THIRDS_PI),
          t.lineTo(i + Math.sin(u) * h, n - Math.cos(u) * h),
          t.closePath();
        break;
      case 'rectRounded':
        (s = h - (l = 0.516 * h)),
          (a = Math.cos(u + QUARTER_PI) * s),
          (r = Math.sin(u + QUARTER_PI) * s),
          t.arc(i - a, n - r, l, u - PI, u - HALF_PI),
          t.arc(i + r, n - a, l, u - HALF_PI, u),
          t.arc(i + a, n + r, l, u, u + HALF_PI),
          t.arc(i - r, n + a, l, u + HALF_PI, u + PI),
          t.closePath();
        break;
      case 'rect':
        if (!d) {
          (s = Math.SQRT1_2 * h), t.rect(i - s, n - s, 2 * s, 2 * s);
          break;
        }
        u += QUARTER_PI;
      case 'rectRot':
        (a = Math.cos(u) * h),
          (r = Math.sin(u) * h),
          t.moveTo(i - a, n - r),
          t.lineTo(i + r, n - a),
          t.lineTo(i + a, n + r),
          t.lineTo(i - r, n + a),
          t.closePath();
        break;
      case 'crossRot':
        u += QUARTER_PI;
      case 'cross':
        (a = Math.cos(u) * h),
          (r = Math.sin(u) * h),
          t.moveTo(i - a, n - r),
          t.lineTo(i + a, n + r),
          t.moveTo(i + r, n - a),
          t.lineTo(i - r, n + a);
        break;
      case 'star':
        (a = Math.cos(u) * h),
          (r = Math.sin(u) * h),
          t.moveTo(i - a, n - r),
          t.lineTo(i + a, n + r),
          t.moveTo(i + r, n - a),
          t.lineTo(i - r, n + a),
          (u += QUARTER_PI),
          (a = Math.cos(u) * h),
          (r = Math.sin(u) * h),
          t.moveTo(i - a, n - r),
          t.lineTo(i + a, n + r),
          t.moveTo(i + r, n - a),
          t.lineTo(i - r, n + a);
        break;
      case 'line':
        (a = Math.cos(u) * h),
          (r = Math.sin(u) * h),
          t.moveTo(i - a, n - r),
          t.lineTo(i + a, n + r);
        break;
      case 'dash':
        t.moveTo(i, n), t.lineTo(i + Math.cos(u) * h, n + Math.sin(u) * h);
    }
    t.fill(), e.borderWidth > 0 && t.stroke();
  }
}
function _isPointInArea(t, e) {
  return (
    t.x > e.left - 0.5 &&
    t.x < e.right + 0.5 &&
    t.y > e.top - 0.5 &&
    t.y < e.bottom + 0.5
  );
}
function clipArea(t, e) {
  t.save(),
    t.beginPath(),
    t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top),
    t.clip();
}
function unclipArea(t) {
  t.restore();
}
function _steppedLineTo(t, e, i, n, o) {
  if (!e) return t.lineTo(i.x, i.y);
  if ('middle' === o) {
    const n = (e.x + i.x) / 2;
    t.lineTo(n, e.y), t.lineTo(n, i.y);
  } else ('after' === o) != !!n ? t.lineTo(e.x, i.y) : t.lineTo(i.x, e.y);
  t.lineTo(i.x, i.y);
}
function _bezierCurveTo(t, e, i, n) {
  if (!e) return t.lineTo(i.x, i.y);
  t.bezierCurveTo(
    n ? e.controlPointPreviousX : e.controlPointNextX,
    n ? e.controlPointPreviousY : e.controlPointNextY,
    n ? i.controlPointNextX : i.controlPointPreviousX,
    n ? i.controlPointNextY : i.controlPointPreviousY,
    i.x,
    i.y,
  );
}
var canvas = Object.freeze({
  __proto__: null,
  toFontString: toFontString,
  _measureText: _measureText,
  _longestText: _longestText,
  _alignPixel: _alignPixel,
  clear: clear,
  drawPoint: drawPoint,
  _isPointInArea: _isPointInArea,
  clipArea: clipArea,
  unclipArea: unclipArea,
  _steppedLineTo: _steppedLineTo,
  _bezierCurveTo: _bezierCurveTo,
});
function toLineHeight(t, e) {
  const i = ('' + t).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
  if (!i || 'normal' === i[1]) return 1.2 * e;
  switch (((t = +i[2]), i[3])) {
    case 'px':
      return t;
    case '%':
      t /= 100;
  }
  return e * t;
}
function toPadding(t) {
  let e, i, n, o;
  return (
    isObject(t)
      ? ((e = +t.top || 0),
        (i = +t.right || 0),
        (n = +t.bottom || 0),
        (o = +t.left || 0))
      : (e = i = n = o = +t || 0),
    { top: e, right: i, bottom: n, left: o, height: e + n, width: o + i }
  );
}
function toFont(t) {
  const e = defaults.font;
  let i = valueOrDefault((t = t || {}).size, e.size);
  'string' == typeof i && (i = parseInt(i, 10));
  const n = {
    color: valueOrDefault(t.color, e.color),
    family: valueOrDefault(t.family, e.family),
    lineHeight: toLineHeight(valueOrDefault(t.lineHeight, e.lineHeight), i),
    lineWidth: valueOrDefault(t.lineWidth, e.lineWidth),
    size: i,
    style: valueOrDefault(t.style, e.style),
    weight: valueOrDefault(t.weight, e.weight),
    strokeStyle: valueOrDefault(t.strokeStyle, e.strokeStyle),
    string: '',
  };
  return (n.string = toFontString(n)), n;
}
function resolve(t, e, i, n) {
  let o,
    a,
    r,
    s = !0;
  for (o = 0, a = t.length; o < a; ++o)
    if (
      void 0 !== (r = t[o]) &&
      (void 0 !== e && 'function' == typeof r && ((r = r(e)), (s = !1)),
      void 0 !== i && isArray(r) && ((r = r[i % r.length]), (s = !1)),
      void 0 !== r)
    )
      return n && !s && (n.cacheable = !1), r;
}
var options = Object.freeze({
  __proto__: null,
  toLineHeight: toLineHeight,
  toPadding: toPadding,
  toFont: toFont,
  resolve: resolve,
});
const map = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15,
  },
  hex = '0123456789ABCDEF',
  h1 = (t) => hex[15 & t],
  h2 = (t) => hex[(240 & t) >> 4] + hex[15 & t],
  eq = (t) => (240 & t) >> 4 == (15 & t);
function isShort(t) {
  return eq(t.r) && eq(t.g) && eq(t.b) && eq(t.a);
}
function hexParse(t) {
  var e,
    i = t.length;
  return (
    '#' === t[0] &&
      (4 === i || 5 === i
        ? (e = {
            r: 255 & (17 * map[t[1]]),
            g: 255 & (17 * map[t[2]]),
            b: 255 & (17 * map[t[3]]),
            a: 5 === i ? 17 * map[t[4]] : 255,
          })
        : (7 !== i && 9 !== i) ||
          (e = {
            r: (map[t[1]] << 4) | map[t[2]],
            g: (map[t[3]] << 4) | map[t[4]],
            b: (map[t[5]] << 4) | map[t[6]],
            a: 9 === i ? (map[t[7]] << 4) | map[t[8]] : 255,
          })),
    e
  );
}
function hexString(t) {
  var e = isShort(t) ? h1 : h2;
  return t ? '#' + e(t.r) + e(t.g) + e(t.b) + (t.a < 255 ? e(t.a) : '') : t;
}
function round(t) {
  return (t + 0.5) | 0;
}
const lim = (t, e, i) => Math.max(Math.min(t, i), e);
function p2b(t) {
  return lim(round(2.55 * t), 0, 255);
}
function n2b(t) {
  return lim(round(255 * t), 0, 255);
}
function b2n(t) {
  return lim(round(t / 2.55) / 100, 0, 1);
}
function n2p(t) {
  return lim(round(100 * t), 0, 100);
}
const RGB_RE =
  /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,\/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(t) {
  const e = RGB_RE.exec(t);
  let i,
    n,
    o,
    a = 255;
  if (e) {
    if (e[7] !== i) {
      const t = +e[7];
      a = 255 & (e[8] ? p2b(t) : 255 * t);
    }
    return (
      (i = +e[1]),
      (n = +e[3]),
      (o = +e[5]),
      {
        r: (i = 255 & (e[2] ? p2b(i) : i)),
        g: (n = 255 & (e[4] ? p2b(n) : n)),
        b: (o = 255 & (e[6] ? p2b(o) : o)),
        a: a,
      }
    );
  }
}
function rgbString(t) {
  return (
    t &&
    (t.a < 255
      ? `rgba(${t.r}, ${t.g}, ${t.b}, ${b2n(t.a)})`
      : `rgb(${t.r}, ${t.g}, ${t.b})`)
  );
}
const HUE_RE =
  /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(t, e, i) {
  const n = e * Math.min(i, 1 - i),
    o = (e, o = (e + t / 30) % 12) =>
      i - n * Math.max(Math.min(o - 3, 9 - o, 1), -1);
  return [o(0), o(8), o(4)];
}
function hsv2rgbn(t, e, i) {
  const n = (n, o = (n + t / 60) % 6) =>
    i - i * e * Math.max(Math.min(o, 4 - o, 1), 0);
  return [n(5), n(3), n(1)];
}
function hwb2rgbn(t, e, i) {
  const n = hsl2rgbn(t, 1, 0.5);
  let o;
  for (e + i > 1 && ((e *= o = 1 / (e + i)), (i *= o)), o = 0; o < 3; o++)
    (n[o] *= 1 - e - i), (n[o] += e);
  return n;
}
function rgb2hsl(t) {
  const e = t.r / 255,
    i = t.g / 255,
    n = t.b / 255,
    o = Math.max(e, i, n),
    a = Math.min(e, i, n),
    r = (o + a) / 2;
  let s, l, c;
  return (
    o !== a &&
      ((c = o - a),
      (l = r > 0.5 ? c / (2 - o - a) : c / (o + a)),
      (s =
        60 *
          (s =
            o === e
              ? (i - n) / c + (i < n ? 6 : 0)
              : o === i
              ? (n - e) / c + 2
              : (e - i) / c + 4) +
        0.5)),
    [0 | s, l || 0, r]
  );
}
function calln(t, e, i, n) {
  return (Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, i, n)).map(n2b);
}
function hsl2rgb(t, e, i) {
  return calln(hsl2rgbn, t, e, i);
}
function hwb2rgb(t, e, i) {
  return calln(hwb2rgbn, t, e, i);
}
function hsv2rgb(t, e, i) {
  return calln(hsv2rgbn, t, e, i);
}
function hue(t) {
  return ((t % 360) + 360) % 360;
}
function hueParse(t) {
  const e = HUE_RE.exec(t);
  let i,
    n = 255;
  if (!e) return;
  e[5] !== i && (n = e[6] ? p2b(+e[5]) : n2b(+e[5]));
  const o = hue(+e[2]),
    a = +e[3] / 100,
    r = +e[4] / 100;
  return {
    r: (i =
      'hwb' === e[1]
        ? hwb2rgb(o, a, r)
        : 'hsv' === e[1]
        ? hsv2rgb(o, a, r)
        : hsl2rgb(o, a, r))[0],
    g: i[1],
    b: i[2],
    a: n,
  };
}
function rotate(t, e) {
  var i = rgb2hsl(t);
  (i[0] = hue(i[0] + e)),
    (i = hsl2rgb(i)),
    (t.r = i[0]),
    (t.g = i[1]),
    (t.b = i[2]);
}
function hslString(t) {
  if (!t) return;
  const e = rgb2hsl(t),
    i = e[0],
    n = n2p(e[1]),
    o = n2p(e[2]);
  return t.a < 255
    ? `hsla(${i}, ${n}%, ${o}%, ${b2n(t.a)})`
    : `hsl(${i}, ${n}%, ${o}%)`;
}
const map$1 = {
    x: 'dark',
    Z: 'light',
    Y: 're',
    X: 'blu',
    W: 'gr',
    V: 'medium',
    U: 'slate',
    A: 'ee',
    T: 'ol',
    S: 'or',
    B: 'ra',
    C: 'lateg',
    D: 'ights',
    R: 'in',
    Q: 'turquois',
    E: 'hi',
    P: 'ro',
    O: 'al',
    N: 'le',
    M: 'de',
    L: 'yello',
    F: 'en',
    K: 'ch',
    G: 'arks',
    H: 'ea',
    I: 'ightg',
    J: 'wh',
  },
  names = {
    OiceXe: 'f0f8ff',
    antiquewEte: 'faebd7',
    aqua: 'ffff',
    aquamarRe: '7fffd4',
    azuY: 'f0ffff',
    beige: 'f5f5dc',
    bisque: 'ffe4c4',
    black: '0',
    blanKedOmond: 'ffebcd',
    Xe: 'ff',
    XeviTet: '8a2be2',
    bPwn: 'a52a2a',
    burlywood: 'deb887',
    caMtXe: '5f9ea0',
    KartYuse: '7fff00',
    KocTate: 'd2691e',
    cSO: 'ff7f50',
    cSnflowerXe: '6495ed',
    cSnsilk: 'fff8dc',
    crimson: 'dc143c',
    cyan: 'ffff',
    xXe: '8b',
    xcyan: '8b8b',
    xgTMnPd: 'b8860b',
    xWay: 'a9a9a9',
    xgYF: '6400',
    xgYy: 'a9a9a9',
    xkhaki: 'bdb76b',
    xmagFta: '8b008b',
    xTivegYF: '556b2f',
    xSange: 'ff8c00',
    xScEd: '9932cc',
    xYd: '8b0000',
    xsOmon: 'e9967a',
    xsHgYF: '8fbc8f',
    xUXe: '483d8b',
    xUWay: '2f4f4f',
    xUgYy: '2f4f4f',
    xQe: 'ced1',
    xviTet: '9400d3',
    dAppRk: 'ff1493',
    dApskyXe: 'bfff',
    dimWay: '696969',
    dimgYy: '696969',
    dodgerXe: '1e90ff',
    fiYbrick: 'b22222',
    flSOwEte: 'fffaf0',
    foYstWAn: '228b22',
    fuKsia: 'ff00ff',
    gaRsbSo: 'dcdcdc',
    ghostwEte: 'f8f8ff',
    gTd: 'ffd700',
    gTMnPd: 'daa520',
    Way: '808080',
    gYF: '8000',
    gYFLw: 'adff2f',
    gYy: '808080',
    honeyMw: 'f0fff0',
    hotpRk: 'ff69b4',
    RdianYd: 'cd5c5c',
    Rdigo: '4b0082',
    ivSy: 'fffff0',
    khaki: 'f0e68c',
    lavFMr: 'e6e6fa',
    lavFMrXsh: 'fff0f5',
    lawngYF: '7cfc00',
    NmoncEffon: 'fffacd',
    ZXe: 'add8e6',
    ZcSO: 'f08080',
    Zcyan: 'e0ffff',
    ZgTMnPdLw: 'fafad2',
    ZWay: 'd3d3d3',
    ZgYF: '90ee90',
    ZgYy: 'd3d3d3',
    ZpRk: 'ffb6c1',
    ZsOmon: 'ffa07a',
    ZsHgYF: '20b2aa',
    ZskyXe: '87cefa',
    ZUWay: '778899',
    ZUgYy: '778899',
    ZstAlXe: 'b0c4de',
    ZLw: 'ffffe0',
    lime: 'ff00',
    limegYF: '32cd32',
    lRF: 'faf0e6',
    magFta: 'ff00ff',
    maPon: '800000',
    VaquamarRe: '66cdaa',
    VXe: 'cd',
    VScEd: 'ba55d3',
    VpurpN: '9370db',
    VsHgYF: '3cb371',
    VUXe: '7b68ee',
    VsprRggYF: 'fa9a',
    VQe: '48d1cc',
    VviTetYd: 'c71585',
    midnightXe: '191970',
    mRtcYam: 'f5fffa',
    mistyPse: 'ffe4e1',
    moccasR: 'ffe4b5',
    navajowEte: 'ffdead',
    navy: '80',
    Tdlace: 'fdf5e6',
    Tive: '808000',
    TivedBb: '6b8e23',
    Sange: 'ffa500',
    SangeYd: 'ff4500',
    ScEd: 'da70d6',
    pOegTMnPd: 'eee8aa',
    pOegYF: '98fb98',
    pOeQe: 'afeeee',
    pOeviTetYd: 'db7093',
    papayawEp: 'ffefd5',
    pHKpuff: 'ffdab9',
    peru: 'cd853f',
    pRk: 'ffc0cb',
    plum: 'dda0dd',
    powMrXe: 'b0e0e6',
    purpN: '800080',
    YbeccapurpN: '663399',
    Yd: 'ff0000',
    Psybrown: 'bc8f8f',
    PyOXe: '4169e1',
    saddNbPwn: '8b4513',
    sOmon: 'fa8072',
    sandybPwn: 'f4a460',
    sHgYF: '2e8b57',
    sHshell: 'fff5ee',
    siFna: 'a0522d',
    silver: 'c0c0c0',
    skyXe: '87ceeb',
    UXe: '6a5acd',
    UWay: '708090',
    UgYy: '708090',
    snow: 'fffafa',
    sprRggYF: 'ff7f',
    stAlXe: '4682b4',
    tan: 'd2b48c',
    teO: '8080',
    tEstN: 'd8bfd8',
    tomato: 'ff6347',
    Qe: '40e0d0',
    viTet: 'ee82ee',
    JHt: 'f5deb3',
    wEte: 'ffffff',
    wEtesmoke: 'f5f5f5',
    Lw: 'ffff00',
    LwgYF: '9acd32',
  };
function unpack() {
  const t = {},
    e = Object.keys(names),
    i = Object.keys(map$1);
  let n, o, a, r, s;
  for (n = 0; n < e.length; n++) {
    for (r = s = e[n], o = 0; o < i.length; o++)
      (a = i[o]), (s = s.replace(a, map$1[a]));
    (a = parseInt(names[r], 16)),
      (t[s] = [(a >> 16) & 255, (a >> 8) & 255, 255 & a]);
  }
  return t;
}
let names$1;
function nameParse(t) {
  names$1 || ((names$1 = unpack()).transparent = [0, 0, 0, 0]);
  const e = names$1[t.toLowerCase()];
  return e && { r: e[0], g: e[1], b: e[2], a: 4 === e.length ? e[3] : 255 };
}
function modHSL(t, e, i) {
  if (t) {
    let n = rgb2hsl(t);
    (n[e] = Math.max(0, Math.min(n[e] + n[e] * i, 0 === e ? 360 : 1))),
      (n = hsl2rgb(n)),
      (t.r = n[0]),
      (t.g = n[1]),
      (t.b = n[2]);
  }
}
function clone$1(t, e) {
  return t ? Object.assign(e || {}, t) : t;
}
function fromObject(t) {
  var e = { r: 0, g: 0, b: 0, a: 255 };
  return (
    Array.isArray(t)
      ? t.length >= 3 &&
        ((e = { r: t[0], g: t[1], b: t[2], a: 255 }),
        t.length > 3 && (e.a = n2b(t[3])))
      : ((e = clone$1(t, { r: 0, g: 0, b: 0, a: 1 })).a = n2b(e.a)),
    e
  );
}
function functionParse(t) {
  return 'r' === t.charAt(0) ? rgbParse(t) : hueParse(t);
}
class Color {
  constructor(t) {
    if (t instanceof Color) return t;
    const e = typeof t;
    let i;
    'object' === e
      ? (i = fromObject(t))
      : 'string' === e && (i = hexParse(t) || nameParse(t) || functionParse(t)),
      (this._rgb = i),
      (this._valid = !!i);
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var t = clone$1(this._rgb);
    return t && (t.a = b2n(t.a)), t;
  }
  set rgb(t) {
    this._rgb = fromObject(t);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : this._rgb;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : this._rgb;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : this._rgb;
  }
  mix(t, e) {
    const i = this;
    if (t) {
      const n = i.rgb,
        o = t.rgb;
      let a;
      const r = e === a ? 0.5 : e,
        s = 2 * r - 1,
        l = n.a - o.a,
        c = ((s * l == -1 ? s : (s + l) / (1 + s * l)) + 1) / 2;
      (a = 1 - c),
        (n.r = 255 & (c * n.r + a * o.r + 0.5)),
        (n.g = 255 & (c * n.g + a * o.g + 0.5)),
        (n.b = 255 & (c * n.b + a * o.b + 0.5)),
        (n.a = r * n.a + (1 - r) * o.a),
        (i.rgb = n);
    }
    return i;
  }
  clone() {
    return new Color(this.rgb);
  }
  alpha(t) {
    return (this._rgb.a = n2b(t)), this;
  }
  clearer(t) {
    return (this._rgb.a *= 1 - t), this;
  }
  greyscale() {
    const t = this._rgb,
      e = round(0.3 * t.r + 0.59 * t.g + 0.11 * t.b);
    return (t.r = t.g = t.b = e), this;
  }
  opaquer(t) {
    return (this._rgb.a *= 1 + t), this;
  }
  negate() {
    const t = this._rgb;
    return (t.r = 255 - t.r), (t.g = 255 - t.g), (t.b = 255 - t.b), this;
  }
  lighten(t) {
    return modHSL(this._rgb, 2, t), this;
  }
  darken(t) {
    return modHSL(this._rgb, 2, -t), this;
  }
  saturate(t) {
    return modHSL(this._rgb, 1, t), this;
  }
  desaturate(t) {
    return modHSL(this._rgb, 1, -t), this;
  }
  rotate(t) {
    return rotate(this._rgb, t), this;
  }
}
function index_esm(t) {
  return new Color(t);
}
const isPatternOrGradient = (t) =>
  t instanceof CanvasGradient || t instanceof CanvasPattern;
function color(t) {
  return isPatternOrGradient(t) ? t : index_esm(t);
}
function getHoverColor(t) {
  return isPatternOrGradient(t)
    ? t
    : index_esm(t).saturate(0.5).darken(0.1).hexString();
}
const transparent = 'transparent',
  interpolators = {
    boolean: (t, e, i) => (i > 0.5 ? e : t),
    color(t, e, i) {
      const n = color(t || transparent),
        o = n.valid && color(e || transparent);
      return o && o.valid ? o.mix(n, i).hexString() : e;
    },
    number: (t, e, i) => t + (e - t) * i,
  };
class Animation {
  constructor(t, e, i, n) {
    const o = e[i];
    n = resolve([t.to, n, o, t.from]);
    const a = resolve([t.from, o, n]);
    (this._active = !0),
      (this._fn = t.fn || interpolators[t.type || typeof a]),
      (this._easing = effects[t.easing || 'linear']),
      (this._start = Math.floor(Date.now() + (t.delay || 0))),
      (this._duration = Math.floor(t.duration)),
      (this._loop = !!t.loop),
      (this._target = e),
      (this._prop = i),
      (this._from = a),
      (this._to = n);
  }
  active() {
    return this._active;
  }
  update(t, e, i) {
    const n = this;
    if (n._active) {
      const o = n._target[n._prop],
        a = i - n._start,
        r = n._duration - a;
      (n._start = i),
        (n._duration = Math.floor(Math.max(r, t.duration))),
        (n._to = resolve([t.to, e, o, t.from])),
        (n._from = resolve([t.from, o, e]));
    }
  }
  cancel() {
    const t = this;
    t._active && (t.tick(Date.now()), (t._active = !1));
  }
  tick(t) {
    const e = this,
      i = t - e._start,
      n = e._duration,
      o = e._prop,
      a = e._from,
      r = e._loop,
      s = e._to;
    let l;
    (e._active = a !== s && (r || i < n)),
      e._active
        ? i < 0
          ? (e._target[o] = a)
          : ((l = (i / n) % 2),
            (l = r && l > 1 ? 2 - l : l),
            (l = e._easing(Math.min(1, Math.max(0, l)))),
            (e._target[o] = e._fn(a, s, l)))
        : (e._target[o] = s);
  }
}
const numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'],
  colors = ['borderColor', 'backgroundColor'];
function copyOptions(t, e) {
  const i = t.options,
    n = e.options;
  i &&
    n &&
    !n.$shared &&
    (i.$shared
      ? (t.options = Object.assign({}, i, n, { $shared: !1 }))
      : Object.assign(i, n),
    delete e.options);
}
function extensibleConfig(t) {
  const e = {};
  return (
    Object.keys(t).forEach((i) => {
      const n = t[i];
      isObject(n) || (e[i] = n);
    }),
    e
  );
}
defaults.set('animation', {
  duration: 1e3,
  easing: 'easeOutQuart',
  onProgress: noop,
  onComplete: noop,
  colors: { type: 'color', properties: colors },
  numbers: { type: 'number', properties: numbers },
  active: { duration: 400 },
  resize: { duration: 0 },
  show: {
    colors: { type: 'color', properties: colors, from: 'transparent' },
    visible: { type: 'boolean', duration: 0 },
  },
  hide: {
    colors: { type: 'color', properties: colors, to: 'transparent' },
    visible: { type: 'boolean', easing: 'easeInExpo' },
  },
});
class Animations {
  constructor(t, e) {
    (this._chart = t), (this._properties = new Map()), this.configure(e);
  }
  configure(t) {
    if (!isObject(t)) return;
    const e = this._properties,
      i = extensibleConfig(t);
    Object.keys(t).forEach((n) => {
      const o = t[n];
      isObject(o) &&
        (o.properties || [n]).forEach((t) => {
          e.has(t)
            ? t === n && e.set(t, Object.assign({}, e.get(t), o))
            : e.set(t, Object.assign({}, i, o));
        });
    });
  }
  _animateOptions(t, e) {
    const i = e.options;
    let n = [];
    if (!i) return n;
    let o = t.options;
    return (
      o
        ? (o.$shared &&
            (t.options = o =
              Object.assign({}, o, { $shared: !1, $animations: {} })),
          (n = this._createAnimations(o, i)))
        : (t.options = i),
      n
    );
  }
  _createAnimations(t, e) {
    const i = this._properties,
      n = [],
      o = t.$animations || (t.$animations = {}),
      a = Object.keys(e),
      r = Date.now();
    let s;
    for (s = a.length - 1; s >= 0; --s) {
      const l = a[s];
      if ('$' === l.charAt(0)) continue;
      if ('options' === l) {
        n.push(...this._animateOptions(t, e));
        continue;
      }
      const c = e[l];
      let d = o[l];
      const h = i.get(l);
      if (d) {
        if (h && d.active()) {
          d.update(h, c, r);
          continue;
        }
        d.cancel();
      }
      h && h.duration
        ? ((o[l] = d = new Animation(h, t, l, c)), n.push(d))
        : (t[l] = c);
    }
    return n;
  }
  update(t, e) {
    if (0 === this._properties.size)
      return copyOptions(t, e), void Object.assign(t, e);
    const i = this._createAnimations(t, e);
    return i.length ? (animator.add(this._chart, i), !0) : void 0;
  }
}
function _lookup(t, e) {
  let i,
    n = t.length - 1,
    o = 0;
  for (; n - o > 1; ) t[(i = (o + n) >> 1)] < e ? (o = i) : (n = i);
  return { lo: o, hi: n };
}
function _lookupByKey(t, e, i) {
  let n,
    o = t.length - 1,
    a = 0;
  for (; o - a > 1; ) t[(n = (a + o) >> 1)][e] < i ? (a = n) : (o = n);
  return { lo: a, hi: o };
}
function _rlookupByKey(t, e, i) {
  let n,
    o = t.length - 1,
    a = 0;
  for (; o - a > 1; ) t[(n = (a + o) >> 1)][e] < i ? (o = n) : (a = n);
  return { lo: a, hi: o };
}
function _filterBetween(t, e, i) {
  let n = 0,
    o = t.length;
  for (; n < o && t[n] < e; ) n++;
  for (; o > n && t[o - 1] > i; ) o--;
  return n > 0 || o < t.length ? t.slice(n, o) : t;
}
const arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];
function listenArrayEvents(t, e) {
  t._chartjs
    ? t._chartjs.listeners.push(e)
    : (Object.defineProperty(t, '_chartjs', {
        configurable: !0,
        enumerable: !1,
        value: { listeners: [e] },
      }),
      arrayEvents.forEach((e) => {
        const i = '_onData' + e.charAt(0).toUpperCase() + e.slice(1),
          n = t[e];
        Object.defineProperty(t, e, {
          configurable: !0,
          enumerable: !1,
          value(...e) {
            const o = n.apply(this, e);
            return (
              t._chartjs.listeners.forEach((t) => {
                'function' == typeof t[i] && t[i](...e);
              }),
              o
            );
          },
        });
      }));
}
function unlistenArrayEvents(t, e) {
  const i = t._chartjs;
  if (!i) return;
  const n = i.listeners,
    o = n.indexOf(e);
  -1 !== o && n.splice(o, 1),
    n.length > 0 ||
      (arrayEvents.forEach((e) => {
        delete t[e];
      }),
      delete t._chartjs);
}
const PI$1 = Math.PI,
  TAU = 2 * PI$1,
  PITAU = TAU + PI$1;
function _factorize(t) {
  const e = [],
    i = Math.sqrt(t);
  let n;
  for (n = 1; n < i; n++) t % n == 0 && (e.push(n), e.push(t / n));
  return i === (0 | i) && e.push(i), e.sort((t, e) => t - e).pop(), e;
}
const log10 =
  Math.log10 ||
  function (t) {
    const e = Math.log(t) * Math.LOG10E,
      i = Math.round(e);
    return t === Math.pow(10, i) ? i : e;
  };
function isNumber(t) {
  return !isNaN(parseFloat(t)) && isFinite(t);
}
function almostEquals(t, e, i) {
  return Math.abs(t - e) < i;
}
function almostWhole(t, e) {
  const i = Math.round(t);
  return i - e <= t && i + e >= t;
}
function _setMinAndMaxByKey(t, e, i) {
  let n, o, a;
  for (n = 0, o = t.length; n < o; n++)
    (a = t[n][i]),
      isNaN(a) || ((e.min = Math.min(e.min, a)), (e.max = Math.max(e.max, a)));
}
const sign = Math.sign
  ? function (t) {
      return Math.sign(t);
    }
  : function (t) {
      return 0 === (t = +t) || isNaN(t) ? t : t > 0 ? 1 : -1;
    };
function toRadians(t) {
  return t * (PI$1 / 180);
}
function toDegrees(t) {
  return t * (180 / PI$1);
}
function _decimalPlaces(t) {
  if (!isNumberFinite(t)) return;
  let e = 1,
    i = 0;
  for (; Math.round(t * e) / e !== t; ) (e *= 10), i++;
  return i;
}
function getAngleFromPoint(t, e) {
  const i = e.x - t.x,
    n = e.y - t.y,
    o = Math.sqrt(i * i + n * n);
  let a = Math.atan2(n, i);
  return a < -0.5 * PI$1 && (a += TAU), { angle: a, distance: o };
}
function distanceBetweenPoints(t, e) {
  return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));
}
function _angleDiff(t, e) {
  return ((t - e + PITAU) % TAU) - PI$1;
}
function _normalizeAngle(t) {
  return ((t % TAU) + TAU) % TAU;
}
function _angleBetween(t, e, i) {
  const n = _normalizeAngle(t),
    o = _normalizeAngle(e),
    a = _normalizeAngle(i),
    r = _normalizeAngle(o - n),
    s = _normalizeAngle(a - n),
    l = _normalizeAngle(n - o),
    c = _normalizeAngle(n - a);
  return n === o || n === a || (r > s && l < c);
}
function _limitValue(t, e, i) {
  return Math.max(e, Math.min(i, t));
}
var math = Object.freeze({
  __proto__: null,
  _factorize: _factorize,
  log10: log10,
  isNumber: isNumber,
  almostEquals: almostEquals,
  almostWhole: almostWhole,
  _setMinAndMaxByKey: _setMinAndMaxByKey,
  sign: sign,
  toRadians: toRadians,
  toDegrees: toDegrees,
  _decimalPlaces: _decimalPlaces,
  getAngleFromPoint: getAngleFromPoint,
  distanceBetweenPoints: distanceBetweenPoints,
  _angleDiff: _angleDiff,
  _normalizeAngle: _normalizeAngle,
  _angleBetween: _angleBetween,
  _limitValue: _limitValue,
});
function scaleClip(t, e) {
  const i = (t && t.options) || {},
    n = i.reverse,
    o = void 0 === i.min ? e : 0,
    a = void 0 === i.max ? e : 0;
  return { start: n ? a : o, end: n ? o : a };
}
function defaultClip(t, e, i) {
  if (!1 === i) return !1;
  const n = scaleClip(t, i),
    o = scaleClip(e, i);
  return { top: o.end, right: n.end, bottom: o.start, left: n.start };
}
function toClip(t) {
  let e, i, n, o;
  return (
    isObject(t)
      ? ((e = t.top), (i = t.right), (n = t.bottom), (o = t.left))
      : (e = i = n = o = t),
    { top: e, right: i, bottom: n, left: o }
  );
}
function getSortedDatasetIndices(t, e) {
  const i = [],
    n = t._getSortedDatasetMetas(e);
  let o, a;
  for (o = 0, a = n.length; o < a; ++o) i.push(n[o].index);
  return i;
}
function applyStack(t, e, i, n) {
  const o = t.keys;
  let a, r, s, l;
  for (a = 0, r = o.length; a < r; ++a) {
    if ((s = +o[a]) === i) {
      if (n) continue;
      break;
    }
    (l = t.values[s]), isNaN(l) || (0 !== e && sign(e) !== sign(l)) || (e += l);
  }
  return e;
}
function convertObjectDataToArray(t) {
  const e = Object.keys(t),
    i = new Array(e.length);
  let n, o, a;
  for (n = 0, o = e.length; n < o; ++n) (a = e[n]), (i[n] = { x: a, y: t[a] });
  return i;
}
function isStacked(t, e) {
  const i = t && t.options.stacked;
  return i || (void 0 === i && void 0 !== e.stack);
}
function getStackKey(t, e, i) {
  return t.id + '.' + e.id + '.' + i.stack + '.' + i.type;
}
function getUserBounds(t) {
  const { min: e, max: i, minDefined: n, maxDefined: o } = t.getUserBounds();
  return {
    min: n ? e : Number.NEGATIVE_INFINITY,
    max: o ? i : Number.POSITIVE_INFINITY,
  };
}
function getOrCreateStack(t, e, i) {
  const n = t[e] || (t[e] = {});
  return n[i] || (n[i] = {});
}
function updateStacks(t, e) {
  const { chart: i, _cachedMeta: n } = t,
    o = i._stacks || (i._stacks = {}),
    { iScale: a, vScale: r, index: s } = n,
    l = a.axis,
    c = r.axis,
    d = getStackKey(a, r, n),
    h = e.length;
  let u;
  for (let t = 0; t < h; ++t) {
    const i = e[t],
      { [l]: n, [c]: a } = i;
    (u = (i._stacks || (i._stacks = {}))[c] = getOrCreateStack(o, d, n))[s] = a;
  }
}
function getFirstScaleId(t, e) {
  const i = t.scales;
  return Object.keys(i)
    .filter((t) => i[t].axis === e)
    .shift();
}
class DatasetController {
  constructor(t, e) {
    (this.chart = t),
      (this._ctx = t.ctx),
      (this.index = e),
      (this._cachedAnimations = {}),
      (this._cachedDataOpts = {}),
      (this._cachedMeta = this.getMeta()),
      (this._type = this._cachedMeta.type),
      (this._config = void 0),
      (this._parsing = !1),
      (this._data = void 0),
      (this._objectData = void 0),
      this.initialize();
  }
  initialize() {
    const t = this._cachedMeta;
    this.configure(),
      this.linkScales(),
      (t._stacked = isStacked(t.vScale, t)),
      this.addElements();
  }
  updateIndex(t) {
    this.index = t;
  }
  linkScales() {
    const t = this,
      e = t.chart,
      i = t._cachedMeta,
      n = t.getDataset(),
      o = (i.xAxisID = n.xAxisID || getFirstScaleId(e, 'x')),
      a = (i.yAxisID = n.yAxisID || getFirstScaleId(e, 'y')),
      r = (i.rAxisID = n.rAxisID || getFirstScaleId(e, 'r'));
    (i.xScale = t.getScaleForId(o)),
      (i.yScale = t.getScaleForId(a)),
      (i.rScale = t.getScaleForId(r)),
      (i.iScale = t._getIndexScale()),
      (i.vScale = t._getValueScale());
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(t) {
    return this.chart.scales[t];
  }
  getValueScaleId() {
    return this._cachedMeta.yAxisID;
  }
  getIndexScaleId() {
    return this._cachedMeta.xAxisID;
  }
  _getValueScale() {
    return this.getScaleForId(this.getValueScaleId());
  }
  _getIndexScale() {
    return this.getScaleForId(this.getIndexScaleId());
  }
  _getOtherScale(t) {
    const e = this._cachedMeta;
    return t === e.iScale ? e.vScale : e.iScale;
  }
  reset() {
    this._update('reset');
  }
  _destroy() {
    this._data && unlistenArrayEvents(this._data, this);
  }
  _dataCheck() {
    const t = this,
      e = t.getDataset(),
      i = e.data || (e.data = []);
    isObject(i)
      ? (t._data = convertObjectDataToArray(i))
      : t._data !== i &&
        (t._data && unlistenArrayEvents(t._data, t),
        i && Object.isExtensible(i) && listenArrayEvents(i, t),
        (t._data = i));
  }
  addElements() {
    const t = this,
      e = t._cachedMeta;
    t._dataCheck();
    const i = t._data,
      n = (e.data = new Array(i.length));
    for (let e = 0, o = i.length; e < o; ++e) n[e] = new t.dataElementType();
    t.datasetElementType && (e.dataset = new t.datasetElementType());
  }
  buildOrUpdateElements() {
    const t = this,
      e = t._cachedMeta,
      i = t.getDataset();
    let n = !1;
    t._dataCheck(),
      (e._stacked = isStacked(e.vScale, e)),
      e.stack !== i.stack &&
        ((n = !0),
        e._parsed.forEach((t) => {
          delete t._stacks[e.vScale.id][e.index];
        }),
        (e.stack = i.stack)),
      t._resyncElements(),
      n && updateStacks(t, e._parsed);
  }
  configure() {
    const t = this;
    (t._config = merge(
      {},
      [t.chart.options[t._type].datasets, t.getDataset()],
      {
        merger(t, e, i) {
          'data' !== t && _merger(t, e, i);
        },
      },
    )),
      (t._parsing = resolve([t._config.parsing, t.chart.options.parsing, !0]));
  }
  parse(t, e) {
    const i = this,
      { _cachedMeta: n, _data: o } = i,
      { iScale: a, vScale: r, _stacked: s } = n,
      l = a.axis;
    let c,
      d,
      h,
      u,
      g = !0;
    if ((t > 0 && ((g = n._sorted), (u = n._parsed[t - 1])), !1 === i._parsing))
      (n._parsed = o), (n._sorted = !0);
    else {
      for (
        d = isArray(o[t])
          ? i.parseArrayData(n, o, t, e)
          : isObject(o[t])
          ? i.parseObjectData(n, o, t, e)
          : i.parsePrimitiveData(n, o, t, e),
          c = 0;
        c < e;
        ++c
      )
        (n._parsed[c + t] = h = d[c]),
          g && (u && h[l] < u[l] && (g = !1), (u = h));
      n._sorted = g;
    }
    s && updateStacks(i, d), a.invalidateCaches(), r.invalidateCaches();
  }
  parsePrimitiveData(t, e, i, n) {
    const { iScale: o, vScale: a } = t,
      r = o.axis,
      s = a.axis,
      l = o.getLabels(),
      c = o === a,
      d = new Array(n);
    let h, u, g;
    for (h = 0, u = n; h < u; ++h)
      (g = h + i),
        (d[h] = { [r]: c || o.parse(l[g], g), [s]: a.parse(e[g], g) });
    return d;
  }
  parseArrayData(t, e, i, n) {
    const { xScale: o, yScale: a } = t,
      r = new Array(n);
    let s, l, c, d;
    for (s = 0, l = n; s < l; ++s)
      (d = e[(c = s + i)]),
        (r[s] = { x: o.parse(d[0], c), y: a.parse(d[1], c) });
    return r;
  }
  parseObjectData(t, e, i, n) {
    const { xScale: o, yScale: a } = t,
      r = new Array(n);
    let s, l, c, d;
    for (s = 0, l = n; s < l; ++s)
      (d = e[(c = s + i)]),
        (r[s] = { x: o.parseObject(d, 'x', c), y: a.parseObject(d, 'y', c) });
    return r;
  }
  getParsed(t) {
    return this._cachedMeta._parsed[t];
  }
  applyStack(t, e) {
    const i = this.chart,
      n = this._cachedMeta,
      o = e[t.axis];
    return applyStack(
      { keys: getSortedDatasetIndices(i, !0), values: e._stacks[t.axis] },
      o,
      n.index,
    );
  }
  updateRangeFromParsed(t, e, i, n) {
    let o = i[e.axis];
    const a = n && i._stacks[e.axis];
    n &&
      a &&
      ((n.values = a),
      (t.min = Math.min(t.min, o)),
      (t.max = Math.max(t.max, o)),
      (o = applyStack(n, o, this._cachedMeta.index, !0))),
      (t.min = Math.min(t.min, o)),
      (t.max = Math.max(t.max, o));
  }
  getMinMax(t, e) {
    const i = this,
      n = i._cachedMeta,
      o = n._parsed,
      a = n._sorted && t === n.iScale,
      r = o.length,
      s = i._getOtherScale(t),
      l = e &&
        n._stacked && {
          keys: getSortedDatasetIndices(i.chart, !0),
          values: null,
        },
      c = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY },
      { min: d, max: h } = getUserBounds(s);
    let u, g, p, f;
    function m() {
      return (
        (p = o[u]), (g = p[t.axis]), (f = p[s.axis]), isNaN(g) || d > f || h < f
      );
    }
    for (
      u = 0;
      u < r && (m() || (i.updateRangeFromParsed(c, t, p, l), !a));
      ++u
    );
    if (a)
      for (u = r - 1; u >= 0; --u)
        if (!m()) {
          i.updateRangeFromParsed(c, t, p, l);
          break;
        }
    return c;
  }
  getAllParsedValues(t) {
    const e = this._cachedMeta._parsed,
      i = [];
    let n, o, a;
    for (n = 0, o = e.length; n < o; ++n)
      (a = e[n][t.axis]), isNaN(a) || i.push(a);
    return i;
  }
  getMaxOverflow() {
    return !1;
  }
  getLabelAndValue(t) {
    const e = this._cachedMeta,
      i = e.iScale,
      n = e.vScale,
      o = this.getParsed(t);
    return {
      label: i ? '' + i.getLabelForValue(o[i.axis]) : '',
      value: n ? '' + n.getLabelForValue(o[n.axis]) : '',
    };
  }
  _update(t) {
    const e = this,
      i = e._cachedMeta;
    e.configure(),
      (e._cachedAnimations = {}),
      (e._cachedDataOpts = {}),
      e.update(t),
      (i._clip = toClip(
        valueOrDefault(
          e._config.clip,
          defaultClip(i.xScale, i.yScale, e.getMaxOverflow()),
        ),
      ));
  }
  update(t) {}
  draw() {
    const t = this._ctx,
      e = this._cachedMeta,
      i = e.data || [],
      n = i.length;
    let o = 0;
    for (e.dataset && e.dataset.draw(t); o < n; ++o) i[o].draw(t);
  }
  _addAutomaticHoverColors(t, e) {
    const i = this.getStyle(t),
      n = Object.keys(i).filter((t) => -1 !== t.indexOf('Color') && !(t in e));
    let o,
      a = n.length - 1;
    for (; a >= 0; a--) (o = n[a]), (e[o] = getHoverColor(i[o]));
  }
  getStyle(t, e) {
    const i = this,
      n = i._cachedMeta.dataset;
    i._config || i.configure();
    const o =
      n && void 0 === t
        ? i.resolveDatasetElementOptions(e)
        : i.resolveDataElementOptions(t || 0, e && 'active');
    return e && i._addAutomaticHoverColors(t, o), o;
  }
  _getContext(t, e) {
    return {
      chart: this.chart,
      dataIndex: t,
      dataset: this.getDataset(),
      datasetIndex: this.index,
      active: e,
    };
  }
  resolveDatasetElementOptions(t) {
    const e = this,
      i = e.chart,
      n = e._config,
      o = i.options.elements[e.datasetElementType._type] || {},
      a = e.datasetElementOptions,
      r = {},
      s = e._getContext(void 0, t);
    let l, c, d, h, u;
    for (l = 0, c = a.length; l < c; ++l)
      (d = a[l]),
        void 0 !==
          (u = resolve(
            [
              n[(h = t ? 'hover' + d.charAt(0).toUpperCase() + d.slice(1) : d)],
              o[h],
            ],
            s,
          )) && (r[d] = u);
    return r;
  }
  resolveDataElementOptions(t, e) {
    const i = this,
      n = 'active' === e,
      o = i._cachedDataOpts;
    if (o[e]) return o[e];
    const a = i.chart,
      r = i._config,
      s = a.options.elements[i.dataElementType._type] || {},
      l = i.dataElementOptions,
      c = {},
      d = i._getContext(t, n),
      h = { cacheable: !n };
    let u, g, p, f, m, b;
    if (isArray(l))
      for (g = 0, p = l.length; g < p; ++g)
        (f = l[g]),
          void 0 !==
            (m = resolve(
              [
                r[
                  (b = n ? 'hover' + f.charAt(0).toUpperCase() + f.slice(1) : f)
                ],
                s[b],
              ],
              d,
              t,
              h,
            )) && (c[f] = m);
    else
      for (g = 0, p = (u = Object.keys(l)).length; g < p; ++g)
        (f = u[g]),
          void 0 !==
            (m = resolve(
              [
                r[
                  l[
                    (b = n
                      ? 'hover' + f.charAt(0).toUpperCase() + f.slice(1)
                      : f)
                  ]
                ],
                r[b],
                s[b],
              ],
              d,
              t,
              h,
            )) && (c[f] = m);
    return h.cacheable && ((c.$shared = !0), (o[e] = c)), c;
  }
  _resolveAnimations(t, e, i) {
    const n = this.chart,
      o = this._cachedAnimations;
    if (o[(e = e || 'default')]) return o[e];
    const a = { cacheable: !0 },
      r = this._getContext(t, i);
    let s = mergeIf({}, [
      resolve([this._config.animation], r, t, a),
      resolve([n.options.animation], r, t, a),
    ]);
    s[e] && (s = Object.assign({}, s, s[e]));
    const l = new Animations(n, s);
    return a.cacheable && (o[e] = l && Object.freeze(l)), l;
  }
  getSharedOptions(t, e, i) {
    if (
      (t || (this._sharedOptions = i && i.$shared),
      'reset' !== t && i && i.$shared && e && e.options && e.options.$shared)
    )
      return { target: e.options, options: i };
  }
  includeOptions(t, e) {
    return 'hide' === t || 'show' === t || ('resize' !== t && !e);
  }
  updateElement(t, e, i, n) {
    'reset' === n || 'none' === n
      ? Object.assign(t, i)
      : this._resolveAnimations(e, n).update(t, i);
  }
  updateSharedOptions(t, e) {
    t && this._resolveAnimations(void 0, e).update(t.target, t.options);
  }
  _setStyle(t, e, i, n) {
    (t.active = n),
      this._resolveAnimations(e, i, n).update(t, {
        options: this.getStyle(e, n),
      });
  }
  removeHoverStyle(t, e, i) {
    this._setStyle(t, i, 'active', !1);
  }
  setHoverStyle(t, e, i) {
    this._setStyle(t, i, 'active', !0);
  }
  _removeDatasetHoverStyle() {
    const t = this._cachedMeta.dataset;
    t && this._setStyle(t, void 0, 'active', !1);
  }
  _setDatasetHoverStyle() {
    const t = this._cachedMeta.dataset;
    t && this._setStyle(t, void 0, 'active', !0);
  }
  _resyncElements() {
    const t = this,
      e = t._cachedMeta,
      i = e.data.length,
      n = t._data.length;
    n > i
      ? t._insertElements(i, n - i)
      : n < i && (e.data.splice(n, i - n), e._parsed.splice(n, i - n)),
      t.parse(0, Math.min(n, i));
  }
  _insertElements(t, e) {
    const i = this,
      n = new Array(e),
      o = i._cachedMeta,
      a = o.data;
    let r;
    for (r = 0; r < e; ++r) n[r] = new i.dataElementType();
    a.splice(t, 0, ...n),
      i._parsing && o._parsed.splice(t, 0, ...new Array(e)),
      i.parse(t, e),
      i.updateElements(n, t, 'reset');
  }
  updateElements(t, e, i) {}
  _removeElements(t, e) {
    const i = this;
    i._parsing && i._cachedMeta._parsed.splice(t, e),
      i._cachedMeta.data.splice(t, e);
  }
  _onDataPush() {
    const t = arguments.length;
    this._insertElements(this.getDataset().data.length - t, t);
  }
  _onDataPop() {
    this._removeElements(this._cachedMeta.data.length - 1, 1);
  }
  _onDataShift() {
    this._removeElements(0, 1);
  }
  _onDataSplice(t, e) {
    this._removeElements(t, e), this._insertElements(t, arguments.length - 2);
  }
  _onDataUnshift() {
    this._insertElements(0, arguments.length);
  }
}
(DatasetController.prototype.datasetElementType = null),
  (DatasetController.prototype.dataElementType = null),
  (DatasetController.prototype.datasetElementOptions = [
    'backgroundColor',
    'borderCapStyle',
    'borderColor',
    'borderDash',
    'borderDashOffset',
    'borderJoinStyle',
    'borderWidth',
  ]),
  (DatasetController.prototype.dataElementOptions = [
    'backgroundColor',
    'borderColor',
    'borderWidth',
    'pointStyle',
  ]);
class Element {
  constructor() {
    (this.x = void 0),
      (this.y = void 0),
      (this.active = !1),
      (this.options = void 0),
      (this.$animations = void 0);
  }
  tooltipPosition(t) {
    const { x: e, y: i } = this.getProps(['x', 'y'], t);
    return { x: e, y: i };
  }
  hasValue() {
    return isNumber(this.x) && isNumber(this.y);
  }
  getProps(t, e) {
    const i = this,
      n = this.$animations;
    if (!e || !n) return i;
    const o = {};
    return (
      t.forEach((t) => {
        o[t] = n[t] && n[t].active ? n[t]._to : i[t];
      }),
      o
    );
  }
}
const TAU$1 = 2 * Math.PI,
  scope = 'elements.arc';
function clipArc(t, e) {
  const { startAngle: i, endAngle: n, pixelMargin: o, x: a, y: r } = e;
  let s = o / e.outerRadius;
  t.beginPath(),
    t.arc(a, r, e.outerRadius, i - s, n + s),
    e.innerRadius > o
      ? ((s = o / e.innerRadius),
        t.arc(a, r, e.innerRadius - o, n + s, i - s, !0))
      : t.arc(a, r, o, n + Math.PI / 2, i - Math.PI / 2),
    t.closePath(),
    t.clip();
}
function pathArc(t, e) {
  t.beginPath(),
    t.arc(e.x, e.y, e.outerRadius, e.startAngle, e.endAngle),
    t.arc(e.x, e.y, e.innerRadius, e.endAngle, e.startAngle, !0),
    t.closePath();
}
function drawArc(t, e, i) {
  if (e.fullCircles) {
    (e.endAngle = e.startAngle + TAU$1), pathArc(t, e);
    for (let i = 0; i < e.fullCircles; ++i) t.fill();
    e.endAngle = e.startAngle + (i % TAU$1);
  }
  pathArc(t, e), t.fill();
}
function drawFullCircleBorders(t, e, i, n) {
  const o = i.endAngle;
  let a;
  for (
    n &&
      ((i.endAngle = i.startAngle + TAU$1),
      clipArc(t, i),
      (i.endAngle = o),
      i.endAngle === i.startAngle &&
        i.fullCircles &&
        ((i.endAngle += TAU$1), i.fullCircles--)),
      t.beginPath(),
      t.arc(i.x, i.y, i.innerRadius, i.startAngle + TAU$1, i.startAngle, !0),
      a = 0;
    a < i.fullCircles;
    ++a
  )
    t.stroke();
  for (
    t.beginPath(),
      t.arc(i.x, i.y, e.outerRadius, i.startAngle, i.startAngle + TAU$1),
      a = 0;
    a < i.fullCircles;
    ++a
  )
    t.stroke();
}
function drawBorder(t, e, i) {
  const n = e.options,
    o = 'inner' === n.borderAlign;
  o
    ? ((t.lineWidth = 2 * n.borderWidth), (t.lineJoin = 'round'))
    : ((t.lineWidth = n.borderWidth), (t.lineJoin = 'bevel')),
    i.fullCircles && drawFullCircleBorders(t, e, i, o),
    o && clipArc(t, i),
    t.beginPath(),
    t.arc(i.x, i.y, e.outerRadius, i.startAngle, i.endAngle),
    t.arc(i.x, i.y, i.innerRadius, i.endAngle, i.startAngle, !0),
    t.closePath(),
    t.stroke();
}
defaults.set(scope, {
  borderAlign: 'center',
  borderColor: '#fff',
  borderWidth: 2,
}),
  defaults.route(scope, ['backgroundColor'], '', ['color']);
class Arc extends Element {
  constructor(t) {
    super(),
      (this.options = void 0),
      (this.circumference = void 0),
      (this.startAngle = void 0),
      (this.endAngle = void 0),
      (this.innerRadius = void 0),
      (this.outerRadius = void 0),
      t && Object.assign(this, t);
  }
  inRange(t, e, i) {
    const n = this.getProps(['x', 'y'], i),
      { angle: o, distance: a } = getAngleFromPoint(n, { x: t, y: e }),
      {
        startAngle: r,
        endAngle: s,
        innerRadius: l,
        outerRadius: c,
        circumference: d,
      } = this.getProps(
        [
          'startAngle',
          'endAngle',
          'innerRadius',
          'outerRadius',
          'circumference',
        ],
        i,
      );
    return (d >= TAU$1 || _angleBetween(o, r, s)) && a >= l && a <= c;
  }
  getCenterPoint(t) {
    const {
        x: e,
        y: i,
        startAngle: n,
        endAngle: o,
        innerRadius: a,
        outerRadius: r,
      } = this.getProps(
        ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius'],
        t,
      ),
      s = (n + o) / 2,
      l = (a + r) / 2;
    return { x: e + Math.cos(s) * l, y: i + Math.sin(s) * l };
  }
  tooltipPosition(t) {
    return this.getCenterPoint(t);
  }
  draw(t) {
    const e = this,
      i = e.options,
      n = 'inner' === i.borderAlign ? 0.33 : 0,
      o = {
        x: e.x,
        y: e.y,
        innerRadius: e.innerRadius,
        outerRadius: Math.max(e.outerRadius - n, 0),
        pixelMargin: n,
        startAngle: e.startAngle,
        endAngle: e.endAngle,
        fullCircles: Math.floor(e.circumference / TAU$1),
      };
    0 !== e.circumference &&
      (t.save(),
      (t.fillStyle = i.backgroundColor),
      (t.strokeStyle = i.borderColor),
      drawArc(t, o, e.circumference),
      i.borderWidth && drawBorder(t, e, o),
      t.restore());
  }
}
function _pointInLine(t, e, i, n) {
  return { x: t.x + i * (e.x - t.x), y: t.y + i * (e.y - t.y) };
}
function _steppedInterpolation(t, e, i, n) {
  return {
    x: t.x + i * (e.x - t.x),
    y:
      'middle' === n
        ? i < 0.5
          ? t.y
          : e.y
        : 'after' === n
        ? i < 1
          ? t.y
          : e.y
        : i > 0
        ? e.y
        : t.y,
  };
}
function _bezierInterpolation(t, e, i, n) {
  const o = { x: t.controlPointNextX, y: t.controlPointNextY },
    a = { x: e.controlPointPreviousX, y: e.controlPointPreviousY },
    r = _pointInLine(t, o, i),
    s = _pointInLine(o, a, i),
    l = _pointInLine(a, e, i),
    c = _pointInLine(r, s, i),
    d = _pointInLine(s, l, i);
  return _pointInLine(c, d, i);
}
function propertyFn(t) {
  return 'angle' === t
    ? {
        between: _angleBetween,
        compare: _angleDiff,
        normalize: _normalizeAngle,
      }
    : {
        between: (t, e, i) => t >= e && t <= i,
        compare: (t, e) => t - e,
        normalize: (t) => t,
      };
}
function makeSubSegment(t, e, i, n) {
  return { start: t % n, end: e % n, loop: i && (e - t + 1) % n == 0 };
}
function getSegment(t, e, i) {
  const { property: n, start: o, end: a } = i,
    { between: r, normalize: s } = propertyFn(n),
    l = e.length;
  let c,
    d,
    { start: h, end: u, loop: g } = t;
  if (g) {
    for (h += l, u += l, c = 0, d = l; c < d && r(s(e[h % l][n]), o, a); ++c)
      h--, u--;
    (h %= l), (u %= l);
  }
  return u < h && (u += l), { start: h, end: u, loop: g };
}
function _boundSegment(t, e, i) {
  if (!i) return [t];
  const { property: n, start: o, end: a } = i,
    r = e.length,
    { compare: s, between: l, normalize: c } = propertyFn(n),
    { start: d, end: h, loop: u } = getSegment(t, e, i),
    g = [];
  let p,
    f,
    m,
    b,
    x = !1,
    _ = null;
  for (p = d; p <= h; ++p)
    (m = e[p % r]).skip ||
      ((x = l((f = c(m[n])), o, a)),
      null === _ && x && (_ = p > d && s(f, o) > 0 ? b : p),
      null === _ ||
        (x && 0 !== s(f, a)) ||
        (g.push(makeSubSegment(_, p, u, r)), (_ = null)),
      (b = p));
  return null !== _ && g.push(makeSubSegment(_, h, u, r)), g;
}
function _boundSegments(t, e) {
  const i = [],
    n = t.segments;
  for (let o = 0; o < n.length; o++) {
    const a = _boundSegment(n[o], t.points, e);
    a.length && i.push(...a);
  }
  return i;
}
function findStartAndEnd(t, e, i, n) {
  let o = 0,
    a = e - 1;
  if (i && !n) for (; o < e && !t[o].skip; ) o++;
  for (; o < e && t[o].skip; ) o++;
  for (o %= e, i && (a += o); a > o && t[a % e].skip; ) a--;
  return { start: o, end: (a %= e) };
}
function solidSegments(t, e, i, n) {
  const o = t.length,
    a = [];
  let r,
    s = e,
    l = t[e];
  for (r = e + 1; r <= i; ++r) {
    const i = t[r % o];
    i.skip || i.stop
      ? l.skip ||
        ((n = !1),
        a.push({ start: e % o, end: (r - 1) % o, loop: n }),
        (e = s = i.stop ? r : null))
      : ((s = r), l.skip && (e = r)),
      (l = i);
  }
  return null !== s && a.push({ start: e % o, end: s % o, loop: n }), a;
}
function _computeSegments(t) {
  const e = t.points,
    i = t.options.spanGaps,
    n = e.length;
  if (!n) return [];
  const o = !!t._loop,
    { start: a, end: r } = findStartAndEnd(e, n, o, i);
  return !0 === i
    ? [{ start: a, end: r, loop: o }]
    : solidSegments(
        e,
        a,
        r < a ? r + n : r,
        !!t._fullLoop && 0 === a && r === n - 1,
      );
}
Arc._type = 'arc';
const EPSILON = Number.EPSILON || 1e-14;
function splineCurve(t, e, i, n) {
  const o = t.skip ? e : t,
    a = e,
    r = i.skip ? e : i,
    s = Math.sqrt(Math.pow(a.x - o.x, 2) + Math.pow(a.y - o.y, 2)),
    l = Math.sqrt(Math.pow(r.x - a.x, 2) + Math.pow(r.y - a.y, 2));
  let c = s / (s + l),
    d = l / (s + l);
  const h = n * (c = isNaN(c) ? 0 : c),
    u = n * (d = isNaN(d) ? 0 : d);
  return {
    previous: { x: a.x - h * (r.x - o.x), y: a.y - h * (r.y - o.y) },
    next: { x: a.x + u * (r.x - o.x), y: a.y + u * (r.y - o.y) },
  };
}
function splineCurveMonotone(t) {
  const e = (t || []).map((t) => ({ model: t, deltaK: 0, mK: 0 })),
    i = e.length;
  let n, o, a, r, s, l, c, d, h;
  for (n = 0; n < i; ++n)
    if (!(a = e[n]).model.skip) {
      if (
        ((o = n > 0 ? e[n - 1] : null),
        (r = n < i - 1 ? e[n + 1] : null) && !r.model.skip)
      ) {
        const t = r.model.x - a.model.x;
        a.deltaK = 0 !== t ? (r.model.y - a.model.y) / t : 0;
      }
      !o || o.model.skip
        ? (a.mK = a.deltaK)
        : !r || r.model.skip
        ? (a.mK = o.deltaK)
        : sign(o.deltaK) !== sign(a.deltaK)
        ? (a.mK = 0)
        : (a.mK = (o.deltaK + a.deltaK) / 2);
    }
  for (n = 0; n < i - 1; ++n)
    (a = e[n]),
      (r = e[n + 1]),
      a.model.skip ||
        r.model.skip ||
        (almostEquals(a.deltaK, 0, EPSILON)
          ? (a.mK = r.mK = 0)
          : ((s = a.mK / a.deltaK),
            (l = r.mK / a.deltaK),
            (d = Math.pow(s, 2) + Math.pow(l, 2)) <= 9 ||
              ((c = 3 / Math.sqrt(d)),
              (a.mK = s * c * a.deltaK),
              (r.mK = l * c * a.deltaK))));
  for (n = 0; n < i; ++n)
    (a = e[n]).model.skip ||
      ((o = n > 0 ? e[n - 1] : null),
      (r = n < i - 1 ? e[n + 1] : null),
      o &&
        !o.model.skip &&
        ((h = (a.model.x - o.model.x) / 3),
        (a.model.controlPointPreviousX = a.model.x - h),
        (a.model.controlPointPreviousY = a.model.y - h * a.mK)),
      r &&
        !r.model.skip &&
        ((h = (r.model.x - a.model.x) / 3),
        (a.model.controlPointNextX = a.model.x + h),
        (a.model.controlPointNextY = a.model.y + h * a.mK)));
}
function capControlPoint(t, e, i) {
  return Math.max(Math.min(t, i), e);
}
function capBezierPoints(t, e) {
  let i, n, o;
  for (i = 0, n = t.length; i < n; ++i)
    _isPointInArea((o = t[i]), e) &&
      (i > 0 &&
        _isPointInArea(t[i - 1], e) &&
        ((o.controlPointPreviousX = capControlPoint(
          o.controlPointPreviousX,
          e.left,
          e.right,
        )),
        (o.controlPointPreviousY = capControlPoint(
          o.controlPointPreviousY,
          e.top,
          e.bottom,
        ))),
      i < t.length - 1 &&
        _isPointInArea(t[i + 1], e) &&
        ((o.controlPointNextX = capControlPoint(
          o.controlPointNextX,
          e.left,
          e.right,
        )),
        (o.controlPointNextY = capControlPoint(
          o.controlPointNextY,
          e.top,
          e.bottom,
        ))));
}
function _updateBezierControlPoints(t, e, i, n) {
  let o, a, r, s;
  if (
    (e.spanGaps && (t = t.filter((t) => !t.skip)),
    'monotone' === e.cubicInterpolationMode)
  )
    splineCurveMonotone(t);
  else {
    let i = n ? t[t.length - 1] : t[0];
    for (o = 0, a = t.length; o < a; ++o)
      (s = splineCurve(
        i,
        (r = t[o]),
        t[Math.min(o + 1, a - (n ? 0 : 1)) % a],
        e.tension,
      )),
        (r.controlPointPreviousX = s.previous.x),
        (r.controlPointPreviousY = s.previous.y),
        (r.controlPointNextX = s.next.x),
        (r.controlPointNextY = s.next.y),
        (i = r);
  }
  e.capBezierPoints && capBezierPoints(t, i);
}
var curve = Object.freeze({
  __proto__: null,
  splineCurve: splineCurve,
  splineCurveMonotone: splineCurveMonotone,
  _updateBezierControlPoints: _updateBezierControlPoints,
});
const scope$1 = 'elements.line';
function setStyle(t, e) {
  (t.lineCap = e.borderCapStyle),
    t.setLineDash(e.borderDash),
    (t.lineDashOffset = e.borderDashOffset),
    (t.lineJoin = e.borderJoinStyle),
    (t.lineWidth = e.borderWidth),
    (t.strokeStyle = e.borderColor);
}
function lineTo(t, e, i) {
  t.lineTo(i.x, i.y);
}
function getLineMethod(t) {
  return t.stepped ? _steppedLineTo : t.tension ? _bezierCurveTo : lineTo;
}
function pathSegment(t, e, i, n) {
  const { start: o, end: a, loop: r } = i,
    { points: s, options: l } = e,
    c = getLineMethod(l),
    d = s.length;
  let { move: h = !0, reverse: u } = n || {};
  const g = a < o ? d + a - o : a - o;
  let p, f, m;
  for (p = 0; p <= g; ++p)
    (f = s[(o + (u ? g - p : p)) % d]).skip ||
      (h ? (t.moveTo(f.x, f.y), (h = !1)) : c(t, m, f, u, l.stepped), (m = f));
  return r && c(t, m, (f = s[(o + (u ? g : 0)) % d]), u, l.stepped), !!r;
}
function fastPathSegment(t, e, i, n) {
  const o = e.points,
    a = o.length,
    { start: r, end: s } = i,
    { move: l = !0, reverse: c } = n || {},
    d = s < r ? a + s - r : s - r;
  let h,
    u,
    g,
    p,
    f,
    m,
    b = 0,
    x = 0;
  for (
    l && ((u = o[(r + (c ? d : 0)) % a]), t.moveTo(u.x, u.y)), h = 0;
    h <= d;
    ++h
  ) {
    if ((u = o[(r + (c ? d - h : h)) % a]).skip) continue;
    const e = u.x,
      i = u.y,
      n = 0 | e;
    n === g
      ? (i < p ? (p = i) : i > f && (f = i), (b = (x * b + e) / ++x))
      : (p !== f && (t.lineTo(b, f), t.lineTo(b, p), t.lineTo(b, m)),
        t.lineTo(e, i),
        (g = n),
        (x = 0),
        (p = f = i)),
      (m = i);
  }
}
function _getSegmentMethod(t) {
  const e = t.options,
    i = e.borderDash && e.borderDash.length;
  return !(t._loop || e.tension || e.stepped || i)
    ? fastPathSegment
    : pathSegment;
}
function _getInterpolationMethod(t) {
  return t.stepped
    ? _steppedInterpolation
    : t.tension
    ? _bezierInterpolation
    : _pointInLine;
}
defaults.set(scope$1, {
  borderCapStyle: 'butt',
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: 'miter',
  borderWidth: 3,
  capBezierPoints: !0,
  fill: !0,
  tension: 0,
}),
  defaults.route(scope$1, ['backgroundColor', 'borderColor'], '', 'color');
class Line extends Element {
  constructor(t) {
    super(),
      (this.options = void 0),
      (this._loop = void 0),
      (this._fullLoop = void 0),
      (this._controlPointsUpdated = void 0),
      (this._points = void 0),
      (this._segments = void 0),
      t && Object.assign(this, t);
  }
  updateControlPoints(t) {
    const e = this;
    if (e._controlPointsUpdated) return;
    const i = e.options;
    if (i.tension && !i.stepped) {
      const n = i.spanGaps ? e._loop : e._fullLoop;
      _updateBezierControlPoints(e._points, i, t, n);
    }
  }
  set points(t) {
    (this._points = t), delete this._segments;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = _computeSegments(this));
  }
  first() {
    const t = this.segments,
      e = this.points;
    return t.length && e[t[0].start];
  }
  last() {
    const t = this.segments,
      e = this.points,
      i = t.length;
    return i && e[t[i - 1].end];
  }
  interpolate(t, e) {
    const i = this.options,
      n = t[e],
      o = this.points,
      a = _boundSegments(this, { property: e, start: n, end: n });
    if (!a.length) return;
    const r = [],
      s = _getInterpolationMethod(i);
    let l, c;
    for (l = 0, c = a.length; l < c; ++l) {
      const { start: c, end: d } = a[l],
        h = o[c],
        u = o[d];
      if (h === u) {
        r.push(h);
        continue;
      }
      const g = s(h, u, Math.abs((n - h[e]) / (u[e] - h[e])), i.stepped);
      (g[e] = t[e]), r.push(g);
    }
    return 1 === r.length ? r[0] : r;
  }
  pathSegment(t, e, i) {
    return _getSegmentMethod(this)(t, this, e, i);
  }
  path(t) {
    const e = this,
      i = e.segments,
      n = i.length,
      o = _getSegmentMethod(e);
    let a = e._loop;
    for (let r = 0; r < n; ++r) a &= o(t, e, i[r]);
    return !!a;
  }
  draw(t) {
    this.points.length &&
      (t.save(),
      setStyle(t, this.options),
      t.beginPath(),
      this.path(t) && t.closePath(),
      t.stroke(),
      t.restore());
  }
}
Line._type = 'line';
const scope$2 = 'elements.point';
defaults.set(scope$2, {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: 'circle',
  radius: 3,
}),
  defaults.route(scope$2, ['backgroundColor', 'borderColor'], '', 'color');
class Point extends Element {
  constructor(t) {
    super(),
      (this.options = void 0),
      (this.skip = void 0),
      (this.stop = void 0),
      t && Object.assign(this, t);
  }
  inRange(t, e, i) {
    const n = this.options,
      { x: o, y: a } = this.getProps(['x', 'y'], i);
    return (
      Math.pow(t - o, 2) + Math.pow(e - a, 2) <
      Math.pow(n.hitRadius + n.radius, 2)
    );
  }
  inXRange(t, e) {
    const i = this.options,
      { x: n } = this.getProps(['x'], e);
    return Math.abs(t - n) < i.radius + i.hitRadius;
  }
  inYRange(t, e) {
    const i = this.options,
      { y: n } = this.getProps(['x'], e);
    return Math.abs(t - n) < i.radius + i.hitRadius;
  }
  getCenterPoint(t) {
    const { x: e, y: i } = this.getProps(['x', 'y'], t);
    return { x: e, y: i };
  }
  size() {
    const t = this.options || {},
      e = Math.max(t.radius, t.hoverRadius) || 0;
    return 2 * (e + ((e && t.borderWidth) || 0));
  }
  draw(t, e) {
    const i = this,
      n = i.options;
    i.skip ||
      n.radius <= 0 ||
      ((void 0 === e || _isPointInArea(i, e)) &&
        ((t.strokeStyle = n.borderColor),
        (t.lineWidth = n.borderWidth),
        (t.fillStyle = n.backgroundColor),
        drawPoint(t, n, i.x, i.y)));
  }
  getRange() {
    const t = this.options || {};
    return t.radius + t.hitRadius;
  }
}
Point._type = 'point';
const scope$3 = 'elements.rectangle';
function getBarBounds(t, e) {
  const {
    x: i,
    y: n,
    base: o,
    width: a,
    height: r,
  } = t.getProps(['x', 'y', 'base', 'width', 'height'], e);
  let s, l, c, d, h;
  return (
    t.horizontal
      ? ((h = r / 2),
        (s = Math.min(i, o)),
        (l = Math.max(i, o)),
        (c = n - h),
        (d = n + h))
      : ((s = i - (h = a / 2)),
        (l = i + h),
        (c = Math.min(n, o)),
        (d = Math.max(n, o))),
    { left: s, top: c, right: l, bottom: d }
  );
}
function swap(t, e, i) {
  return t === e ? i : t === i ? e : t;
}
function parseBorderSkipped(t) {
  let e = t.options.borderSkipped;
  const i = {};
  return e
    ? (t.horizontal
        ? t.base > t.x && (e = swap(e, 'left', 'right'))
        : t.base < t.y && (e = swap(e, 'bottom', 'top')),
      (i[e] = !0),
      i)
    : i;
}
function skipOrLimit(t, e, i, n) {
  return t ? 0 : Math.max(Math.min(e, n), i);
}
function parseBorderWidth(t, e, i) {
  const n = t.options.borderWidth,
    o = parseBorderSkipped(t);
  let a, r, s, l;
  return (
    isObject(n)
      ? ((a = +n.top || 0),
        (r = +n.right || 0),
        (s = +n.bottom || 0),
        (l = +n.left || 0))
      : (a = r = s = l = +n || 0),
    {
      t: skipOrLimit(o.top, a, 0, i),
      r: skipOrLimit(o.right, r, 0, e),
      b: skipOrLimit(o.bottom, s, 0, i),
      l: skipOrLimit(o.left, l, 0, e),
    }
  );
}
function boundingRects(t) {
  const e = getBarBounds(t),
    i = e.right - e.left,
    n = e.bottom - e.top,
    o = parseBorderWidth(t, i / 2, n / 2);
  return {
    outer: { x: e.left, y: e.top, w: i, h: n },
    inner: {
      x: e.left + o.l,
      y: e.top + o.t,
      w: i - o.l - o.r,
      h: n - o.t - o.b,
    },
  };
}
function inRange(t, e, i, n) {
  const o = null === e,
    a = null === i,
    r = !(!t || (o && a)) && getBarBounds(t, n);
  return (
    r &&
    (o || (e >= r.left && e <= r.right)) &&
    (a || (i >= r.top && i <= r.bottom))
  );
}
defaults.set(scope$3, { borderSkipped: 'bottom', borderWidth: 0 }),
  defaults.route(scope$3, ['backgroundColor', 'borderColor'], '', 'color');
class Rectangle extends Element {
  constructor(t) {
    super(),
      (this.options = void 0),
      (this.horizontal = void 0),
      (this.base = void 0),
      (this.width = void 0),
      (this.height = void 0),
      t && Object.assign(this, t);
  }
  draw(t) {
    const e = this.options,
      { inner: i, outer: n } = boundingRects(this);
    t.save(),
      (n.w === i.w && n.h === i.h) ||
        (t.beginPath(),
        t.rect(n.x, n.y, n.w, n.h),
        t.clip(),
        t.rect(i.x, i.y, i.w, i.h),
        (t.fillStyle = e.borderColor),
        t.fill('evenodd')),
      (t.fillStyle = e.backgroundColor),
      t.fillRect(i.x, i.y, i.w, i.h),
      t.restore();
  }
  inRange(t, e, i) {
    return inRange(this, t, e, i);
  }
  inXRange(t, e) {
    return inRange(this, t, null, e);
  }
  inYRange(t, e) {
    return inRange(this, null, t, e);
  }
  getCenterPoint(t) {
    const {
      x: e,
      y: i,
      base: n,
      horizontal: o,
    } = this.getProps(['x', 'y', 'base', 'horizontal'], t);
    return { x: o ? (e + n) / 2 : e, y: o ? i : (i + n) / 2 };
  }
  getRange(t) {
    return 'x' === t ? this.width / 2 : this.height / 2;
  }
}
Rectangle._type = 'rectangle';
var elements = Object.freeze({
  __proto__: null,
  Arc: Arc,
  Line: Line,
  Point: Point,
  Rectangle: Rectangle,
});
function computeMinSampleSize(t, e) {
  let i,
    n,
    o,
    a,
    r = t._length;
  for (o = 1, a = e.length; o < a; ++o)
    r = Math.min(r, Math.abs(e[o] - e[o - 1]));
  for (o = 0, a = t.ticks.length; o < a; ++o)
    (n = t.getPixelForTick(o)),
      (r = o > 0 ? Math.min(r, Math.abs(n - i)) : r),
      (i = n);
  return r;
}
function computeFitCategoryTraits(t, e, i) {
  const n = i.barThickness,
    o = e.stackCount;
  let a, r;
  return (
    isNullOrUndef(n)
      ? ((a = e.min * i.categoryPercentage), (r = i.barPercentage))
      : ((a = n * o), (r = 1)),
    { chunk: a / o, ratio: r, start: e.pixels[t] - a / 2 }
  );
}
function computeFlexCategoryTraits(t, e, i) {
  const n = e.pixels,
    o = n[t];
  let a = t > 0 ? n[t - 1] : null,
    r = t < n.length - 1 ? n[t + 1] : null;
  const s = i.categoryPercentage;
  null === a && (a = o - (null === r ? e.end - e.start : r - o)),
    null === r && (r = o + o - a);
  const l = o - ((o - Math.min(a, r)) / 2) * s;
  return {
    chunk: ((Math.abs(r - a) / 2) * s) / e.stackCount,
    ratio: i.barPercentage,
    start: l,
  };
}
function parseFloatBar(t, e, i, n) {
  const o = i.parse(t[0], n),
    a = i.parse(t[1], n),
    r = Math.min(o, a),
    s = Math.max(o, a);
  let l = r,
    c = s;
  Math.abs(r) > Math.abs(s) && ((l = s), (c = r)),
    (e[i.axis] = c),
    (e._custom = { barStart: l, barEnd: c, start: o, end: a, min: r, max: s });
}
function parseArrayOrPrimitive(t, e, i, n) {
  const o = t.iScale,
    a = t.vScale,
    r = o.getLabels(),
    s = o === a,
    l = [];
  let c, d, h, u;
  for (c = i, d = i + n; c < d; ++c)
    (u = e[c]),
      ((h = {})[o.axis] = s || o.parse(r[c], c)),
      isArray(u) ? parseFloatBar(u, h, a, c) : (h[a.axis] = a.parse(u, c)),
      l.push(h);
  return l;
}
function isFloatBar(t) {
  return t && void 0 !== t.barStart && void 0 !== t.barEnd;
}
defaults.set('bar', {
  hover: { mode: 'index' },
  datasets: {
    categoryPercentage: 0.8,
    barPercentage: 0.9,
    animation: {
      numbers: {
        type: 'number',
        properties: ['x', 'y', 'base', 'width', 'height'],
      },
    },
  },
  scales: {
    x: { type: 'category', offset: !0, gridLines: { offsetGridLines: !0 } },
    y: { type: 'linear', beginAtZero: !0 },
  },
});
class BarController extends DatasetController {
  parsePrimitiveData(t, e, i, n) {
    return parseArrayOrPrimitive(t, e, i, n);
  }
  parseArrayData(t, e, i, n) {
    return parseArrayOrPrimitive(t, e, i, n);
  }
  parseObjectData(t, e, i, n) {
    const { iScale: o, vScale: a } = t,
      r = a.axis,
      s = [];
    let l, c, d, h, u;
    for (l = i, c = i + n; l < c; ++l)
      (h = e[l]),
        ((d = {})[o.axis] = o.parseObject(h, o.axis, l)),
        isArray((u = h[r]))
          ? parseFloatBar(u, d, a, l)
          : (d[a.axis] = a.parseObject(h, r, l)),
        s.push(d);
    return s;
  }
  updateRangeFromParsed(t, e, i, n) {
    super.updateRangeFromParsed(t, e, i, n);
    const o = i._custom;
    o && ((t.min = Math.min(t.min, o.min)), (t.max = Math.max(t.max, o.max)));
  }
  getLabelAndValue(t) {
    const e = this._cachedMeta,
      { iScale: i, vScale: n } = e,
      o = this.getParsed(t),
      a = o._custom,
      r = isFloatBar(a)
        ? '[' + a.start + ', ' + a.end + ']'
        : '' + n.getLabelForValue(o[n.axis]);
    return { label: '' + i.getLabelForValue(o[i.axis]), value: r };
  }
  initialize() {
    super.initialize(), (this._cachedMeta.stack = this.getDataset().stack);
  }
  update(t) {
    const e = this._cachedMeta;
    this.updateElements(e.data, 0, t);
  }
  updateElements(t, e, i) {
    const n = this,
      o = 'reset' === i,
      a = n._cachedMeta.vScale,
      r = a.getBasePixel(),
      s = a.isHorizontal(),
      l = n._getRuler(),
      c = n.resolveDataElementOptions(e, i),
      d = n.getSharedOptions(i, t[e], c),
      h = n.includeOptions(i, d);
    let u;
    for (u = 0; u < t.length; u++) {
      const a = e + u,
        c = n.resolveDataElementOptions(a, i),
        d = n._calculateBarValuePixels(a, c),
        g = n._calculateBarIndexPixels(a, l, c),
        p = {
          horizontal: s,
          base: o ? r : d.base,
          x: s ? (o ? r : d.head) : g.center,
          y: s ? g.center : o ? r : d.head,
          height: s ? g.size : void 0,
          width: s ? void 0 : g.size,
        };
      h && (p.options = c), n.updateElement(t[u], a, p, i);
    }
    n.updateSharedOptions(d, i);
  }
  _getStacks(t) {
    const e = this._cachedMeta.iScale,
      i = e.getMatchingVisibleMetas(this._type),
      n = e.options.stacked,
      o = i.length,
      a = [];
    let r, s;
    for (
      r = 0;
      r < o &&
      ((s = i[r]),
      (!1 === n ||
        -1 === a.indexOf(s.stack) ||
        (void 0 === n && void 0 === s.stack)) &&
        a.push(s.stack),
      s.index !== t);
      ++r
    );
    return a.length || a.push(void 0), a;
  }
  _getStackCount() {
    return this._getStacks().length;
  }
  _getStackIndex(t, e) {
    const i = this._getStacks(t),
      n = void 0 !== e ? i.indexOf(e) : -1;
    return -1 === n ? i.length - 1 : n;
  }
  _getRuler() {
    const t = this,
      e = t._cachedMeta,
      i = e.iScale,
      n = [];
    let o, a;
    for (o = 0, a = e.data.length; o < a; ++o)
      n.push(i.getPixelForValue(t.getParsed(o)[i.axis]));
    return {
      min: computeMinSampleSize(i, n),
      pixels: n,
      start: i._startPixel,
      end: i._endPixel,
      stackCount: t._getStackCount(),
      scale: i,
    };
  }
  _calculateBarValuePixels(t, e) {
    const i = this._cachedMeta,
      n = i.vScale,
      o = e.minBarLength,
      a = this.getParsed(t),
      r = a._custom;
    let s,
      l,
      c = a[n.axis],
      d = 0,
      h = i._stacked ? this.applyStack(n, a) : c;
    h !== c && ((d = h - c), (h = c)),
      isFloatBar(r) &&
        ((c = r.barStart),
        (h = r.barEnd - r.barStart),
        0 !== c && sign(c) !== sign(r.barEnd) && (d = 0),
        (d += c));
    const u = _limitValue(
      n.getPixelForValue(d),
      n._startPixel - 10,
      n._endPixel + 10,
    );
    return (
      (l = (s = n.getPixelForValue(d + h)) - u),
      void 0 !== o && Math.abs(l) < o && (s = u + (l = l < 0 ? -o : o)),
      { size: l, base: u, head: s, center: s + l / 2 }
    );
  }
  _calculateBarIndexPixels(t, e, i) {
    const n =
        'flex' === i.barThickness
          ? computeFlexCategoryTraits(t, e, i)
          : computeFitCategoryTraits(t, e, i),
      o = this._getStackIndex(this.index, this._cachedMeta.stack),
      a = n.start + n.chunk * o + n.chunk / 2,
      r = Math.min(valueOrDefault(i.maxBarThickness, 1 / 0), n.chunk * n.ratio);
    return { base: a - r / 2, head: a + r / 2, center: a, size: r };
  }
  draw() {
    const t = this,
      e = t.chart,
      i = t._cachedMeta,
      n = i.vScale,
      o = i.data,
      a = o.length;
    let r = 0;
    for (clipArea(e.ctx, e.chartArea); r < a; ++r)
      isNaN(t.getParsed(r)[n.axis]) || o[r].draw(t._ctx);
    unclipArea(e.ctx);
  }
}
(BarController.prototype.dataElementType = Rectangle),
  (BarController.prototype.dataElementOptions = [
    'backgroundColor',
    'borderColor',
    'borderSkipped',
    'borderWidth',
    'barPercentage',
    'barThickness',
    'categoryPercentage',
    'maxBarThickness',
    'minBarLength',
  ]),
  defaults.set('bubble', {
    animation: { numbers: { properties: ['x', 'y', 'borderWidth', 'radius'] } },
    scales: { x: { type: 'linear' }, y: { type: 'linear' } },
    tooltips: { callbacks: { title: () => '' } },
  });
class BubbleController extends DatasetController {
  parseObjectData(t, e, i, n) {
    const { xScale: o, yScale: a } = t,
      r = [];
    let s, l, c;
    for (s = i, l = i + n; s < l; ++s)
      (c = e[s]),
        r.push({
          x: o.parseObject(c, 'x', s),
          y: a.parseObject(c, 'y', s),
          _custom: c && c.r && +c.r,
        });
    return r;
  }
  getMaxOverflow() {
    const t = this;
    let e = (t._cachedMeta.data || []).length - 1,
      i = 0;
    for (; e >= 0; --e) i = Math.max(i, t.getStyle(e, !0).radius);
    return i > 0 && i;
  }
  getLabelAndValue(t) {
    const e = this._cachedMeta,
      { xScale: i, yScale: n } = e,
      o = this.getParsed(t),
      a = i.getLabelForValue(o.x),
      r = n.getLabelForValue(o.y),
      s = o._custom;
    return {
      label: e.label,
      value: '(' + a + ', ' + r + (s ? ', ' + s : '') + ')',
    };
  }
  update(t) {
    const e = this._cachedMeta.data;
    this.updateElements(e, 0, t);
  }
  updateElements(t, e, i) {
    const n = this,
      o = 'reset' === i,
      { xScale: a, yScale: r } = n._cachedMeta,
      s = n.resolveDataElementOptions(e, i),
      l = n.getSharedOptions(i, t[e], s),
      c = n.includeOptions(i, l);
    for (let s = 0; s < t.length; s++) {
      const l = t[s],
        d = e + s,
        h = !o && n.getParsed(d),
        u = o ? a.getPixelForDecimal(0.5) : a.getPixelForValue(h.x),
        g = o ? r.getBasePixel() : r.getPixelForValue(h.y),
        p = { x: u, y: g, skip: isNaN(u) || isNaN(g) };
      c &&
        ((p.options = n.resolveDataElementOptions(d, i)),
        o && (p.options.radius = 0)),
        n.updateElement(l, d, p, i);
    }
    n.updateSharedOptions(l, i);
  }
  resolveDataElementOptions(t, e) {
    const i = this,
      n = i.chart,
      o = i.getDataset(),
      a = i.getParsed(t);
    let r = super.resolveDataElementOptions(t, e);
    const s = { chart: n, dataIndex: t, dataset: o, datasetIndex: i.index };
    return (
      r.$shared && (r = Object.assign({}, r, { $shared: !1 })),
      'active' !== e && (r.radius = 0),
      (r.radius += resolve(
        [a && a._custom, i._config.radius, n.options.elements.point.radius],
        s,
        t,
      )),
      r
    );
  }
}
(BubbleController.prototype.dataElementType = Point),
  (BubbleController.prototype.dataElementOptions = [
    'backgroundColor',
    'borderColor',
    'borderWidth',
    'hitRadius',
    'radius',
    'pointStyle',
    'rotation',
  ]);
const PI$2 = Math.PI,
  DOUBLE_PI$1 = 2 * PI$2,
  HALF_PI$1 = PI$2 / 2;
function getRatioAndOffset(t, e, i) {
  let n = 1,
    o = 1,
    a = 0,
    r = 0;
  if (e < DOUBLE_PI$1) {
    let s = t % DOUBLE_PI$1;
    const l = (s += s >= PI$2 ? -DOUBLE_PI$1 : s < -PI$2 ? DOUBLE_PI$1 : 0) + e,
      c = Math.cos(s),
      d = Math.sin(s),
      h = Math.cos(l),
      u = Math.sin(l),
      g = (s <= 0 && l >= 0) || l >= DOUBLE_PI$1,
      p = (s <= HALF_PI$1 && l >= HALF_PI$1) || l >= DOUBLE_PI$1 + HALF_PI$1,
      f = (s <= -HALF_PI$1 && l >= -HALF_PI$1) || l >= PI$2 + HALF_PI$1,
      m = s === -PI$2 || l >= PI$2 ? -1 : Math.min(c, c * i, h, h * i),
      b = f ? -1 : Math.min(d, d * i, u, u * i),
      x = g ? 1 : Math.max(c, c * i, h, h * i),
      _ = p ? 1 : Math.max(d, d * i, u, u * i);
    (n = (x - m) / 2),
      (o = (_ - b) / 2),
      (a = -(x + m) / 2),
      (r = -(_ + b) / 2);
  }
  return { ratioX: n, ratioY: o, offsetX: a, offsetY: r };
}
defaults.set('doughnut', {
  animation: {
    numbers: {
      type: 'number',
      properties: [
        'circumference',
        'endAngle',
        'innerRadius',
        'outerRadius',
        'startAngle',
        'x',
        'y',
      ],
    },
    animateRotate: !0,
    animateScale: !1,
  },
  aspectRatio: 1,
  legend: {
    labels: {
      generateLabels(t) {
        const e = t.data;
        return e.labels.length && e.datasets.length
          ? e.labels.map((e, i) => {
              const n = t.getDatasetMeta(0).controller.getStyle(i);
              return {
                text: e,
                fillStyle: n.backgroundColor,
                strokeStyle: n.borderColor,
                lineWidth: n.borderWidth,
                hidden: !t.getDataVisibility(i),
                index: i,
              };
            })
          : [];
      },
    },
    onClick(t, e, i) {
      i.chart.toggleDataVisibility(e.index), i.chart.update();
    },
  },
  cutoutPercentage: 50,
  rotation: -HALF_PI$1,
  circumference: DOUBLE_PI$1,
  tooltips: {
    callbacks: {
      title: () => '',
      label(t, e) {
        let i = e.labels[t.index];
        const n = ': ' + e.datasets[t.datasetIndex].data[t.index];
        return isArray(i) ? ((i = i.slice())[0] += n) : (i += n), i;
      },
    },
  },
});
class DoughnutController extends DatasetController {
  constructor(t, e) {
    super(t, e),
      (this.innerRadius = void 0),
      (this.outerRadius = void 0),
      (this.offsetX = void 0),
      (this.offsetY = void 0);
  }
  linkScales() {}
  parse(t, e) {
    const i = this.getDataset().data,
      n = this._cachedMeta;
    let o, a;
    for (o = t, a = t + e; o < a; ++o) n._parsed[o] = +i[o];
  }
  getRingIndex(t) {
    let e = 0;
    for (let i = 0; i < t; ++i) this.chart.isDatasetVisible(i) && ++e;
    return e;
  }
  update(t) {
    const e = this,
      i = e.chart,
      { chartArea: n, options: o } = i,
      a = e._cachedMeta,
      r = a.data,
      s = o.cutoutPercentage / 100 || 0,
      l = e._getRingWeight(e.index),
      {
        ratioX: c,
        ratioY: d,
        offsetX: h,
        offsetY: u,
      } = getRatioAndOffset(o.rotation, o.circumference, s),
      g = e.getMaxBorderWidth(),
      p = (n.right - n.left - g) / c,
      f = (n.bottom - n.top - g) / d,
      m = Math.max(Math.min(p, f) / 2, 0),
      b = (m - Math.max(m * s, 0)) / e._getVisibleDatasetWeightTotal();
    (e.offsetX = h * m),
      (e.offsetY = u * m),
      (a.total = e.calculateTotal()),
      (e.outerRadius = m - b * e._getRingWeightOffset(e.index)),
      (e.innerRadius = Math.max(e.outerRadius - b * l, 0)),
      e.updateElements(r, 0, t);
  }
  _circumference(t, e) {
    const i = this.chart.options,
      n = this._cachedMeta;
    return e && i.animation.animateRotate
      ? 0
      : this.chart.getDataVisibility(t)
      ? this.calculateCircumference(
          (n._parsed[t] * i.circumference) / DOUBLE_PI$1,
        )
      : 0;
  }
  updateElements(t, e, i) {
    const n = this,
      o = 'reset' === i,
      a = n.chart,
      r = a.chartArea,
      s = a.options,
      l = s.animation,
      c = (r.left + r.right) / 2,
      d = (r.top + r.bottom) / 2,
      h = o && l.animateScale,
      u = h ? 0 : n.innerRadius,
      g = h ? 0 : n.outerRadius,
      p = n.resolveDataElementOptions(e, i),
      f = n.getSharedOptions(i, t[e], p),
      m = n.includeOptions(i, f);
    let b,
      x = s.rotation;
    for (b = 0; b < e; ++b) x += n._circumference(b, o);
    for (b = 0; b < t.length; ++b) {
      const a = e + b,
        r = n._circumference(a, o),
        s = t[b],
        l = {
          x: c + n.offsetX,
          y: d + n.offsetY,
          startAngle: x,
          endAngle: x + r,
          circumference: r,
          outerRadius: g,
          innerRadius: u,
        };
      m && (l.options = n.resolveDataElementOptions(a, i)),
        (x += r),
        n.updateElement(s, a, l, i);
    }
    n.updateSharedOptions(f, i);
  }
  calculateTotal() {
    const t = this._cachedMeta,
      e = t.data;
    let i,
      n = 0;
    for (i = 0; i < e.length; i++) {
      const e = t._parsed[i];
      !isNaN(e) && this.chart.getDataVisibility(i) && (n += Math.abs(e));
    }
    return n;
  }
  calculateCircumference(t) {
    const e = this._cachedMeta.total;
    return e > 0 && !isNaN(t) ? DOUBLE_PI$1 * (Math.abs(t) / e) : 0;
  }
  getMaxBorderWidth(t) {
    const e = this;
    let i = 0;
    const n = e.chart;
    let o, a, r, s, l;
    if (!t)
      for (o = 0, a = n.data.datasets.length; o < a; ++o)
        if (n.isDatasetVisible(o)) {
          (t = (r = n.getDatasetMeta(o)).data),
            (s = r.controller) !== e && s.configure();
          break;
        }
    if (!t) return 0;
    for (o = 0, a = t.length; o < a; ++o)
      'inner' !== (l = s.resolveDataElementOptions(o)).borderAlign &&
        (i = Math.max(i, l.borderWidth || 0, l.hoverBorderWidth || 0));
    return i;
  }
  _getRingWeightOffset(t) {
    let e = 0;
    for (let i = 0; i < t; ++i)
      this.chart.isDatasetVisible(i) && (e += this._getRingWeight(i));
    return e;
  }
  _getRingWeight(t) {
    return Math.max(valueOrDefault(this.chart.data.datasets[t].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
(DoughnutController.prototype.dataElementType = Arc),
  (DoughnutController.prototype.dataElementOptions = [
    'backgroundColor',
    'borderColor',
    'borderWidth',
    'borderAlign',
    'hoverBackgroundColor',
    'hoverBorderColor',
    'hoverBorderWidth',
  ]),
  defaults.set('horizontalBar', {
    hover: { mode: 'index', axis: 'y' },
    scales: {
      x: { type: 'linear', beginAtZero: !0 },
      y: { type: 'category', offset: !0, gridLines: { offsetGridLines: !0 } },
    },
    datasets: { categoryPercentage: 0.8, barPercentage: 0.9 },
    elements: { rectangle: { borderSkipped: 'left' } },
    tooltips: { axis: 'y' },
  });
class HorizontalBarController extends BarController {
  getValueScaleId() {
    return this._cachedMeta.xAxisID;
  }
  getIndexScaleId() {
    return this._cachedMeta.yAxisID;
  }
}
defaults.set('line', {
  showLines: !0,
  spanGaps: !1,
  hover: { mode: 'index' },
  scales: { x: { type: 'category' }, y: { type: 'linear' } },
});
class LineController extends DatasetController {
  constructor(t, e) {
    super(t, e), (this._showLine = !1);
  }
  update(t) {
    const e = this,
      i = e._cachedMeta,
      n = i.dataset,
      o = i.data || [],
      a = e.chart.options,
      r = e._config;
    if (
      (e._showLine = valueOrDefault(r.showLine, a.showLines)) &&
      'resize' !== t
    ) {
      const i = { points: o, options: e.resolveDatasetElementOptions() };
      e.updateElement(n, void 0, i, t);
    }
    e.updateElements(o, 0, t);
  }
  updateElements(t, e, i) {
    const n = this,
      o = 'reset' === i,
      { xScale: a, yScale: r, _stacked: s } = n._cachedMeta,
      l = n.resolveDataElementOptions(e, i),
      c = n.getSharedOptions(i, t[e], l),
      d = n.includeOptions(i, c),
      h = valueOrDefault(n._config.spanGaps, n.chart.options.spanGaps),
      u = isNumber(h) ? h : Number.POSITIVE_INFINITY;
    let g;
    for (let l = 0; l < t.length; ++l) {
      const c = e + l,
        h = t[l],
        p = n.getParsed(c),
        f = a.getPixelForValue(p.x),
        m = o
          ? r.getBasePixel()
          : r.getPixelForValue(s ? n.applyStack(r, p) : p.y),
        b = {
          x: f,
          y: m,
          skip: isNaN(f) || isNaN(m),
          stop: l > 0 && p.x - g.x > u,
        };
      d && (b.options = n.resolveDataElementOptions(c, i)),
        n.updateElement(h, c, b, i),
        (g = p);
    }
    n.updateSharedOptions(c, i);
  }
  resolveDatasetElementOptions(t) {
    const e = this._config,
      i = this.chart.options,
      n = i.elements.line,
      o = super.resolveDatasetElementOptions(t);
    return (
      (o.spanGaps = valueOrDefault(e.spanGaps, i.spanGaps)),
      (o.tension = valueOrDefault(e.lineTension, n.tension)),
      (o.stepped = resolve([e.stepped, n.stepped])),
      o
    );
  }
  getMaxOverflow() {
    const t = this._cachedMeta,
      e = (this._showLine && t.dataset.options.borderWidth) || 0,
      i = t.data || [];
    if (!i.length) return e;
    const n = i[0].size(),
      o = i[i.length - 1].size();
    return Math.max(e, n, o) / 2;
  }
  draw() {
    const t = this._ctx,
      e = this.chart,
      i = this._cachedMeta,
      n = i.data || [],
      o = e.chartArea,
      a = [];
    let r,
      s,
      l = n.length;
    for (this._showLine && i.dataset.draw(t, o), r = 0; r < l; ++r)
      (s = n[r]).active ? a.push(s) : s.draw(t, o);
    for (r = 0, l = a.length; r < l; ++r) a[r].draw(t, o);
  }
}
function getStartAngleRadians(t) {
  return toRadians(t) - 0.5 * Math.PI;
}
(LineController.prototype.datasetElementType = Line),
  (LineController.prototype.dataElementType = Point),
  (LineController.prototype.datasetElementOptions = [
    'backgroundColor',
    'borderCapStyle',
    'borderColor',
    'borderDash',
    'borderDashOffset',
    'borderJoinStyle',
    'borderWidth',
    'capBezierPoints',
    'cubicInterpolationMode',
    'fill',
  ]),
  (LineController.prototype.dataElementOptions = {
    backgroundColor: 'pointBackgroundColor',
    borderColor: 'pointBorderColor',
    borderWidth: 'pointBorderWidth',
    hitRadius: 'pointHitRadius',
    hoverHitRadius: 'pointHitRadius',
    hoverBackgroundColor: 'pointHoverBackgroundColor',
    hoverBorderColor: 'pointHoverBorderColor',
    hoverBorderWidth: 'pointHoverBorderWidth',
    hoverRadius: 'pointHoverRadius',
    pointStyle: 'pointStyle',
    radius: 'pointRadius',
    rotation: 'pointRotation',
  }),
  defaults.set('polarArea', {
    animation: {
      numbers: {
        type: 'number',
        properties: [
          'x',
          'y',
          'startAngle',
          'endAngle',
          'innerRadius',
          'outerRadius',
        ],
      },
      animateRotate: !0,
      animateScale: !0,
    },
    aspectRatio: 1,
    scales: {
      r: {
        type: 'radialLinear',
        angleLines: { display: !1 },
        beginAtZero: !0,
        gridLines: { circular: !0 },
        pointLabels: { display: !1 },
      },
    },
    startAngle: 0,
    legend: {
      labels: {
        generateLabels(t) {
          const e = t.data;
          return e.labels.length && e.datasets.length
            ? e.labels.map((e, i) => {
                const n = t.getDatasetMeta(0).controller.getStyle(i);
                return {
                  text: e,
                  fillStyle: n.backgroundColor,
                  strokeStyle: n.borderColor,
                  lineWidth: n.borderWidth,
                  hidden: !t.getDataVisibility(i),
                  index: i,
                };
              })
            : [];
        },
      },
      onClick(t, e, i) {
        i.chart.toggleDataVisibility(e.index), i.chart.update();
      },
    },
    tooltips: {
      callbacks: {
        title: () => '',
        label: (t, e) => e.labels[t.index] + ': ' + t.value,
      },
    },
  });
class PolarAreaController extends DatasetController {
  constructor(t, e) {
    super(t, e), (this.innerRadius = void 0), (this.outerRadius = void 0);
  }
  getIndexScaleId() {
    return this._cachedMeta.rAxisID;
  }
  getValueScaleId() {
    return this._cachedMeta.rAxisID;
  }
  update(t) {
    const e = this._cachedMeta.data;
    this._updateRadius(), this.updateElements(e, 0, t);
  }
  _updateRadius() {
    const t = this,
      e = t.chart,
      i = e.chartArea,
      n = e.options,
      o = Math.min(i.right - i.left, i.bottom - i.top),
      a = Math.max(o / 2, 0),
      r =
        (a -
          Math.max(
            n.cutoutPercentage ? (a / 100) * n.cutoutPercentage : 1,
            0,
          )) /
        e.getVisibleDatasetCount();
    (t.outerRadius = a - r * t.index), (t.innerRadius = t.outerRadius - r);
  }
  updateElements(t, e, i) {
    const n = this,
      o = 'reset' === i,
      a = n.chart,
      r = n.getDataset(),
      s = a.options,
      l = s.animation,
      c = a.scales.r,
      d = c.xCenter,
      h = c.yCenter,
      u = getStartAngleRadians(s.startAngle);
    let g,
      p = u;
    for (n._cachedMeta.count = n.countVisibleElements(), g = 0; g < e; ++g)
      p += n._computeAngle(g);
    for (g = 0; g < t.length; g++) {
      const a = t[g],
        s = e + g;
      let f = p,
        m = p + n._computeAngle(s),
        b = this.chart.getDataVisibility(s)
          ? c.getDistanceFromCenterForValue(r.data[s])
          : 0;
      (p = m),
        o && (l.animateScale && (b = 0), l.animateRotate && ((f = u), (m = u)));
      const x = {
        x: d,
        y: h,
        innerRadius: 0,
        outerRadius: b,
        startAngle: f,
        endAngle: m,
        options: n.resolveDataElementOptions(s, i),
      };
      n.updateElement(a, s, x, i);
    }
  }
  countVisibleElements() {
    const t = this.getDataset(),
      e = this._cachedMeta;
    let i = 0;
    return (
      e.data.forEach((e, n) => {
        !isNaN(t.data[n]) && this.chart.getDataVisibility(n) && i++;
      }),
      i
    );
  }
  _computeAngle(t) {
    const e = this,
      i = e._cachedMeta.count,
      n = e.getDataset();
    if (isNaN(n.data[t]) || !this.chart.getDataVisibility(t)) return 0;
    const o = {
      chart: e.chart,
      dataIndex: t,
      dataset: n,
      datasetIndex: e.index,
    };
    return resolve(
      [e.chart.options.elements.arc.angle, (2 * Math.PI) / i],
      o,
      t,
    );
  }
}
(PolarAreaController.prototype.dataElementType = Arc),
  (PolarAreaController.prototype.dataElementOptions = [
    'backgroundColor',
    'borderColor',
    'borderWidth',
    'borderAlign',
    'hoverBackgroundColor',
    'hoverBorderColor',
    'hoverBorderWidth',
  ]),
  defaults.set('pie', clone(defaults.doughnut)),
  defaults.set('pie', { cutoutPercentage: 0 }),
  defaults.set('radar', {
    aspectRatio: 1,
    spanGaps: !1,
    scales: { r: { type: 'radialLinear' } },
    elements: { line: { fill: 'start', tension: 0 } },
  });
class RadarController extends DatasetController {
  getIndexScaleId() {
    return this._cachedMeta.rAxisID;
  }
  getValueScaleId() {
    return this._cachedMeta.rAxisID;
  }
  getLabelAndValue(t) {
    const e = this._cachedMeta.vScale,
      i = this.getParsed(t);
    return {
      label: e.getLabels()[t],
      value: '' + e.getLabelForValue(i[e.axis]),
    };
  }
  update(t) {
    const e = this,
      i = e._cachedMeta,
      n = i.dataset,
      o = i.data || [],
      a = {
        points: o,
        _loop: !0,
        _fullLoop: i.iScale.getLabels().length === o.length,
        options: e.resolveDatasetElementOptions(),
      };
    e.updateElement(n, void 0, a, t),
      e.updateElements(o, 0, t),
      n.updateControlPoints(e.chart.chartArea);
  }
  updateElements(t, e, i) {
    const n = this,
      o = n.getDataset(),
      a = n.chart.scales.r,
      r = 'reset' === i;
    let s;
    for (s = 0; s < t.length; s++) {
      const l = t[s],
        c = e + s,
        d = n.resolveDataElementOptions(c, i),
        h = a.getPointPositionForValue(c, o.data[c]),
        u = r ? a.xCenter : h.x,
        g = r ? a.yCenter : h.y,
        p = {
          x: u,
          y: g,
          angle: h.angle,
          skip: isNaN(u) || isNaN(g),
          options: d,
        };
      n.updateElement(l, c, p, i);
    }
  }
  resolveDatasetElementOptions(t) {
    const e = this._config,
      i = this.chart.options,
      n = super.resolveDatasetElementOptions(t);
    return (
      (n.spanGaps = valueOrDefault(e.spanGaps, i.spanGaps)),
      (n.tension = valueOrDefault(e.lineTension, i.elements.line.tension)),
      n
    );
  }
}
(RadarController.prototype.datasetElementType = Line),
  (RadarController.prototype.dataElementType = Point),
  (RadarController.prototype.datasetElementOptions = [
    'backgroundColor',
    'borderColor',
    'borderCapStyle',
    'borderDash',
    'borderDashOffset',
    'borderJoinStyle',
    'borderWidth',
    'fill',
  ]),
  (RadarController.prototype.dataElementOptions = {
    backgroundColor: 'pointBackgroundColor',
    borderColor: 'pointBorderColor',
    borderWidth: 'pointBorderWidth',
    hitRadius: 'pointHitRadius',
    hoverBackgroundColor: 'pointHoverBackgroundColor',
    hoverBorderColor: 'pointHoverBorderColor',
    hoverBorderWidth: 'pointHoverBorderWidth',
    hoverRadius: 'pointHoverRadius',
    pointStyle: 'pointStyle',
    radius: 'pointRadius',
    rotation: 'pointRotation',
  }),
  defaults.set('scatter', {
    scales: { x: { type: 'linear' }, y: { type: 'linear' } },
    datasets: { showLine: !1 },
    tooltips: {
      callbacks: {
        title: () => '',
        label: (t) => '(' + t.label + ', ' + t.value + ')',
      },
    },
  });
var controllers = Object.freeze({
  __proto__: null,
  bar: BarController,
  bubble: BubbleController,
  doughnut: DoughnutController,
  horizontalBar: HorizontalBarController,
  line: LineController,
  polarArea: PolarAreaController,
  pie: DoughnutController,
  radar: RadarController,
  scatter: LineController,
});
function isConstrainedValue(t) {
  return null != t && 'none' !== t;
}
function _getParentNode(t) {
  let e = t.parentNode;
  return e && '[object ShadowRoot]' === e.toString() && (e = e.host), e;
}
function parseMaxStyle(t, e, i) {
  let n;
  return (
    'string' == typeof t
      ? ((n = parseInt(t, 10)),
        -1 !== t.indexOf('%') && (n = (n / 100) * e.parentNode[i]))
      : (n = t),
    n
  );
}
function getConstraintDimension(t, e, i) {
  const n = document.defaultView,
    o = _getParentNode(t),
    a = n.getComputedStyle(t)[e],
    r = n.getComputedStyle(o)[e],
    s = isConstrainedValue(a),
    l = isConstrainedValue(r),
    c = Number.POSITIVE_INFINITY;
  if (s || l)
    return Math.min(
      s ? parseMaxStyle(a, t, i) : c,
      l ? parseMaxStyle(r, o, i) : c,
    );
}
function getStyle(t, e) {
  return t.currentStyle
    ? t.currentStyle[e]
    : document.defaultView.getComputedStyle(t, null).getPropertyValue(e);
}
function getConstraintWidth(t) {
  return getConstraintDimension(t, 'max-width', 'clientWidth');
}
function getConstraintHeight(t) {
  return getConstraintDimension(t, 'max-height', 'clientHeight');
}
function _calculatePadding(t, e, i) {
  return '' === (e = getStyle(t, e))
    ? 0
    : e.indexOf('%') > -1
    ? (i * parseInt(e, 10)) / 100
    : parseInt(e, 10);
}
function getRelativePosition(t, e) {
  let i, n;
  const o = t.originalEvent || t,
    a = e.canvas,
    r = a.getBoundingClientRect(),
    s = o.touches;
  s && s.length > 0
    ? ((i = s[0].clientX), (n = s[0].clientY))
    : ((i = o.clientX), (n = o.clientY));
  const l = parseFloat(getStyle(a, 'padding-left')),
    c = parseFloat(getStyle(a, 'padding-top')),
    d = parseFloat(getStyle(a, 'padding-right')),
    h = parseFloat(getStyle(a, 'padding-bottom')),
    u = r.right - r.left - l - d,
    g = r.bottom - r.top - c - h;
  return {
    x: (i = Math.round(
      (((i - r.left - l) / u) * a.width) / e.currentDevicePixelRatio,
    )),
    y: (n = Math.round(
      (((n - r.top - c) / g) * a.height) / e.currentDevicePixelRatio,
    )),
  };
}
function fallbackIfNotValid(t, e) {
  return 'number' == typeof t ? t : e;
}
function getMaximumWidth(t) {
  const e = _getParentNode(t);
  if (!e) return fallbackIfNotValid(t.clientWidth, t.width);
  const i = e.clientWidth,
    n =
      i -
      _calculatePadding(e, 'padding-left', i) -
      _calculatePadding(e, 'padding-right', i),
    o = getConstraintWidth(t);
  return isNaN(o) ? n : Math.min(n, o);
}
function getMaximumHeight(t) {
  const e = _getParentNode(t);
  if (!e) return fallbackIfNotValid(t.clientHeight, t.height);
  const i = e.clientHeight,
    n =
      i -
      _calculatePadding(e, 'padding-top', i) -
      _calculatePadding(e, 'padding-bottom', i),
    o = getConstraintHeight(t);
  return isNaN(o) ? n : Math.min(n, o);
}
function retinaScale(t, e) {
  const i = (t.currentDevicePixelRatio =
      e || ('undefined' != typeof window && window.devicePixelRatio) || 1),
    { canvas: n, width: o, height: a } = t;
  (n.height = a * i),
    (n.width = o * i),
    t.ctx.setTransform(i, 0, 0, i, 0, 0),
    !n.style ||
      n.style.height ||
      n.style.width ||
      ((n.style.height = a + 'px'), (n.style.width = o + 'px'));
}
var dom = Object.freeze({
  __proto__: null,
  _getParentNode: _getParentNode,
  getStyle: getStyle,
  getRelativePosition: getRelativePosition,
  getMaximumWidth: getMaximumWidth,
  getMaximumHeight: getMaximumHeight,
  retinaScale: retinaScale,
});
function getRelativePosition$1(t, e) {
  return 'native' in t ? { x: t.x, y: t.y } : getRelativePosition(t, e);
}
function evaluateAllVisibleItems(t, e) {
  const i = t.getSortedVisibleDatasetMetas();
  let n, o, a;
  for (let t = 0, r = i.length; t < r; ++t) {
    ({ index: n, data: o } = i[t]);
    for (let t = 0, i = o.length; t < i; ++t) (a = o[t]).skip || e(a, n, t);
  }
}
function binarySearch(t, e, i, n) {
  const { controller: o, data: a, _sorted: r } = t,
    s = o._cachedMeta.iScale;
  if (s && e === s.axis && r && a.length) {
    const t = s._reversePixels ? _rlookupByKey : _lookupByKey;
    if (!n) return t(a, e, i);
    if (o._sharedOptions) {
      const n = a[0],
        o = 'function' == typeof n.getRange && n.getRange(e);
      if (o) {
        const n = t(a, e, i - o),
          r = t(a, e, i + o);
        return { lo: n.lo, hi: r.hi };
      }
    }
  }
  return { lo: 0, hi: a.length - 1 };
}
function optimizedEvaluateItems(t, e, i, n, o) {
  const a = t.getSortedVisibleDatasetMetas(),
    r = i[e];
  for (let t = 0, i = a.length; t < i; ++t) {
    const { index: i, data: s } = a[t],
      { lo: l, hi: c } = binarySearch(a[t], e, r, o);
    for (let t = l; t <= c; ++t) {
      const e = s[t];
      e.skip || n(e, i, t);
    }
  }
}
function getDistanceMetricForAxis(t) {
  const e = -1 !== t.indexOf('x'),
    i = -1 !== t.indexOf('y');
  return function (t, n) {
    const o = e ? Math.abs(t.x - n.x) : 0,
      a = i ? Math.abs(t.y - n.y) : 0;
    return Math.sqrt(Math.pow(o, 2) + Math.pow(a, 2));
  };
}
function getIntersectItems(t, e, i, n) {
  const o = [];
  if (!_isPointInArea(e, t.chartArea)) return o;
  return (
    optimizedEvaluateItems(
      t,
      i,
      e,
      function (t, i, a) {
        t.inRange(e.x, e.y, n) &&
          o.push({ element: t, datasetIndex: i, index: a });
      },
      !0,
    ),
    o
  );
}
function getNearestItems(t, e, i, n, o) {
  const a = getDistanceMetricForAxis(i);
  let r = Number.POSITIVE_INFINITY,
    s = [];
  if (!_isPointInArea(e, t.chartArea)) return s;
  return (
    optimizedEvaluateItems(t, i, e, function (t, i, l) {
      if (n && !t.inRange(e.x, e.y, o)) return;
      const c = t.getCenterPoint(o),
        d = a(e, c);
      d < r
        ? ((s = [{ element: t, datasetIndex: i, index: l }]), (r = d))
        : d === r && s.push({ element: t, datasetIndex: i, index: l });
    }),
    s
  );
}
var Interaction = {
  modes: {
    index(t, e, i, n) {
      const o = getRelativePosition$1(e, t),
        a = i.axis || 'x',
        r = i.intersect
          ? getIntersectItems(t, o, a, n)
          : getNearestItems(t, o, a, !1, n),
        s = [];
      return r.length
        ? (t.getSortedVisibleDatasetMetas().forEach((t) => {
            const e = r[0].index,
              i = t.data[e];
            i &&
              !i.skip &&
              s.push({ element: i, datasetIndex: t.index, index: e });
          }),
          s)
        : [];
    },
    dataset(t, e, i, n) {
      const o = getRelativePosition$1(e, t),
        a = i.axis || 'xy';
      let r = i.intersect
        ? getIntersectItems(t, o, a, n)
        : getNearestItems(t, o, a, !1, n);
      if (r.length > 0) {
        const e = r[0].datasetIndex,
          i = t.getDatasetMeta(e).data;
        r = [];
        for (let t = 0; t < i.length; ++t)
          r.push({ element: i[t], datasetIndex: e, index: t });
      }
      return r;
    },
    point: (t, e, i, n) =>
      getIntersectItems(t, getRelativePosition$1(e, t), i.axis || 'xy', n),
    nearest: (t, e, i, n) =>
      getNearestItems(
        t,
        getRelativePosition$1(e, t),
        i.axis || 'xy',
        i.intersect,
        n,
      ),
    x(t, e, i, n) {
      const o = getRelativePosition$1(e, t),
        a = [];
      let r = !1;
      return (
        evaluateAllVisibleItems(t, (t, e, i) => {
          t.inXRange(o.x, n) &&
            a.push({ element: t, datasetIndex: e, index: i }),
            t.inRange(o.x, o.y, n) && (r = !0);
        }),
        i.intersect && !r ? [] : a
      );
    },
    y(t, e, i, n) {
      const o = getRelativePosition$1(e, t),
        a = [];
      let r = !1;
      return (
        evaluateAllVisibleItems(t, (t, e, i) => {
          t.inYRange(o.y, n) &&
            a.push({ element: t, datasetIndex: e, index: i }),
            t.inRange(o.x, o.y, n) && (r = !0);
        }),
        i.intersect && !r ? [] : a
      );
    },
  },
};
const STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];
function filterByPosition(t, e) {
  return t.filter((t) => t.pos === e);
}
function filterDynamicPositionByAxis(t, e) {
  return t.filter(
    (t) => -1 === STATIC_POSITIONS.indexOf(t.pos) && t.box.axis === e,
  );
}
function sortByWeight(t, e) {
  return t.sort((t, i) => {
    const n = e ? i : t,
      o = e ? t : i;
    return n.weight === o.weight ? n.index - o.index : n.weight - o.weight;
  });
}
function wrapBoxes(t) {
  const e = [];
  let i, n, o;
  for (i = 0, n = (t || []).length; i < n; ++i)
    (o = t[i]),
      e.push({
        index: i,
        box: o,
        pos: o.position,
        horizontal: o.isHorizontal(),
        weight: o.weight,
      });
  return e;
}
function setLayoutDims(t, e) {
  let i, n, o;
  for (i = 0, n = t.length; i < n; ++i)
    ((o = t[i]).width = o.horizontal
      ? o.box.fullWidth && e.availableWidth
      : e.vBoxMaxWidth),
      (o.height = o.horizontal && e.hBoxMaxHeight);
}
function buildLayoutBoxes(t) {
  const e = wrapBoxes(t),
    i = sortByWeight(filterByPosition(e, 'left'), !0),
    n = sortByWeight(filterByPosition(e, 'right')),
    o = sortByWeight(filterByPosition(e, 'top'), !0),
    a = sortByWeight(filterByPosition(e, 'bottom')),
    r = filterDynamicPositionByAxis(e, 'x'),
    s = filterDynamicPositionByAxis(e, 'y');
  return {
    leftAndTop: i.concat(o),
    rightAndBottom: n.concat(s).concat(a).concat(r),
    chartArea: filterByPosition(e, 'chartArea'),
    vertical: i.concat(n).concat(s),
    horizontal: o.concat(a).concat(r),
  };
}
function getCombinedMax(t, e, i, n) {
  return Math.max(t[i], e[i]) + Math.max(t[n], e[n]);
}
function updateDims(t, e, i) {
  const n = i.box,
    o = t.maxPadding;
  if (
    (i.size && (t[i.pos] -= i.size),
    (i.size = i.horizontal ? n.height : n.width),
    (t[i.pos] += i.size),
    n.getPadding)
  ) {
    const t = n.getPadding();
    (o.top = Math.max(o.top, t.top)),
      (o.left = Math.max(o.left, t.left)),
      (o.bottom = Math.max(o.bottom, t.bottom)),
      (o.right = Math.max(o.right, t.right));
  }
  const a = e.outerWidth - getCombinedMax(o, t, 'left', 'right'),
    r = e.outerHeight - getCombinedMax(o, t, 'top', 'bottom');
  if (a !== t.w || r !== t.h)
    return (t.w = a), (t.h = r), i.horizontal ? a !== t.w : r !== t.h;
}
function handleMaxPadding(t) {
  const e = t.maxPadding;
  function i(i) {
    const n = Math.max(e[i] - t[i], 0);
    return (t[i] += n), n;
  }
  (t.y += i('top')), (t.x += i('left')), i('right'), i('bottom');
}
function getMargins(t, e) {
  const i = e.maxPadding;
  function n(t) {
    const n = { left: 0, top: 0, right: 0, bottom: 0 };
    return (
      t.forEach((t) => {
        n[t] = Math.max(e[t], i[t]);
      }),
      n
    );
  }
  return n(t ? ['left', 'right'] : ['top', 'bottom']);
}
function fitBoxes(t, e, i) {
  const n = [];
  let o, a, r, s, l, c;
  for (o = 0, a = t.length; o < a; ++o)
    (s = (r = t[o]).box).update(
      r.width || e.w,
      r.height || e.h,
      getMargins(r.horizontal, e),
    ),
      updateDims(e, i, r) && ((c = !0), n.length && (l = !0)),
      s.fullWidth || n.push(r);
  return (l && fitBoxes(n, e, i)) || c;
}
function placeBoxes(t, e, i) {
  const n = i.padding;
  let o,
    a,
    r,
    s,
    l = e.x,
    c = e.y;
  for (o = 0, a = t.length; o < a; ++o)
    (s = (r = t[o]).box),
      r.horizontal
        ? ((s.left = s.fullWidth ? n.left : e.left),
          (s.right = s.fullWidth ? i.outerWidth - n.right : e.left + e.w),
          (s.top = c),
          (s.bottom = c + s.height),
          (s.width = s.right - s.left),
          (c = s.bottom))
        : ((s.left = l),
          (s.right = l + s.width),
          (s.top = e.top),
          (s.bottom = e.top + e.h),
          (s.height = s.bottom - s.top),
          (l = s.right));
  (e.x = l), (e.y = c);
}
defaults.set('layout', { padding: { top: 0, right: 0, bottom: 0, left: 0 } });
var layouts = {
  addBox(t, e) {
    t.boxes || (t.boxes = []),
      (e.fullWidth = e.fullWidth || !1),
      (e.position = e.position || 'top'),
      (e.weight = e.weight || 0),
      (e._layers =
        e._layers ||
        function () {
          return [
            {
              z: 0,
              draw(t) {
                e.draw(t);
              },
            },
          ];
        }),
      t.boxes.push(e);
  },
  removeBox(t, e) {
    const i = t.boxes ? t.boxes.indexOf(e) : -1;
    -1 !== i && t.boxes.splice(i, 1);
  },
  configure(t, e, i) {
    const n = ['fullWidth', 'position', 'weight'],
      o = n.length;
    let a,
      r = 0;
    for (; r < o; ++r)
      (a = n[r]), Object.prototype.hasOwnProperty.call(i, a) && (e[a] = i[a]);
  },
  update(t, e, i) {
    if (!t) return;
    const n = toPadding((t.options.layout || {}).padding),
      o = e - n.width,
      a = i - n.height,
      r = buildLayoutBoxes(t.boxes),
      s = r.vertical,
      l = r.horizontal,
      c = Object.freeze({
        outerWidth: e,
        outerHeight: i,
        padding: n,
        availableWidth: o,
        vBoxMaxWidth: o / 2 / s.length,
        hBoxMaxHeight: a / 2,
      }),
      d = Object.assign(
        { maxPadding: Object.assign({}, n), w: o, h: a, x: n.left, y: n.top },
        n,
      );
    setLayoutDims(s.concat(l), c),
      fitBoxes(s, d, c),
      fitBoxes(l, d, c) && fitBoxes(s, d, c),
      handleMaxPadding(d),
      placeBoxes(r.leftAndTop, d, c),
      (d.x += d.w),
      (d.y += d.h),
      placeBoxes(r.rightAndBottom, d, c),
      (t.chartArea = {
        left: d.left,
        top: d.top,
        right: d.left + d.w,
        bottom: d.top + d.h,
        height: d.h,
        width: d.w,
      }),
      each(r.chartArea, (e) => {
        const i = e.box;
        Object.assign(i, t.chartArea), i.update(d.w, d.h);
      });
  },
};
class BasePlatform {
  acquireContext(t, e) {}
  releaseContext(t) {
    return !1;
  }
  addEventListener(t, e, i) {}
  removeEventListener(t, e, i) {}
  getDevicePixelRatio() {
    return 1;
  }
  isAttached(t) {
    return !0;
  }
}
class BasicPlatform extends BasePlatform {
  acquireContext(t) {
    return (t && t.getContext && t.getContext('2d')) || null;
  }
}
const EXPANDO_KEY = '$chartjs',
  EVENT_TYPES = {
    touchstart: 'mousedown',
    touchmove: 'mousemove',
    touchend: 'mouseup',
    pointerenter: 'mouseenter',
    pointerdown: 'mousedown',
    pointermove: 'mousemove',
    pointerup: 'mouseup',
    pointerleave: 'mouseout',
    pointerout: 'mouseout',
  };
function readUsedSize(t, e) {
  const i = getStyle(t, e),
    n = i && i.match(/^(\d+)(\.\d+)?px$/);
  return n ? +n[1] : void 0;
}
function initCanvas(t, e) {
  const i = t.style,
    n = t.getAttribute('height'),
    o = t.getAttribute('width');
  if (
    ((t[EXPANDO_KEY] = {
      initial: {
        height: n,
        width: o,
        style: { display: i.display, height: i.height, width: i.width },
      },
    }),
    (i.display = i.display || 'block'),
    (i.boxSizing = i.boxSizing || 'border-box'),
    null === o || '' === o)
  ) {
    const e = readUsedSize(t, 'width');
    void 0 !== e && (t.width = e);
  }
  if (null === n || '' === n)
    if ('' === t.style.height)
      t.height = t.width / (e.options.aspectRatio || 2);
    else {
      const e = readUsedSize(t, 'height');
      void 0 !== e && (t.height = e);
    }
  return t;
}
const supportsEventListenerOptions = (function () {
    let t = !1;
    try {
      const e = {
        get passive() {
          return (t = !0), !1;
        },
      };
      window.addEventListener('test', null, e),
        window.removeEventListener('test', null, e);
    } catch (t) {}
    return t;
  })(),
  eventListenerOptions = !!supportsEventListenerOptions && { passive: !0 };
function addListener(t, e, i) {
  t.addEventListener(e, i, eventListenerOptions);
}
function removeListener(t, e, i) {
  t.removeEventListener(e, i, eventListenerOptions);
}
function createEvent(t, e, i, n, o) {
  return {
    type: t,
    chart: e,
    native: o || null,
    x: void 0 !== i ? i : null,
    y: void 0 !== n ? n : null,
  };
}
function fromNativeEvent(t, e) {
  const i = EVENT_TYPES[t.type] || t.type,
    n = getRelativePosition(t, e);
  return createEvent(i, e, n.x, n.y, t);
}
function throttled(t, e) {
  let i = !1,
    n = [];
  return function (...o) {
    (n = Array.prototype.slice.call(o)),
      i ||
        ((i = !0),
        requestAnimFrame.call(window, () => {
          (i = !1), t.apply(e, n);
        }));
  };
}
function createAttachObserver(t, e, i) {
  const n = t.canvas,
    o = (n && _getParentNode(n)) || n,
    a = new MutationObserver((t) => {
      const e = _getParentNode(o);
      t.forEach((t) => {
        for (let n = 0; n < t.addedNodes.length; n++) {
          const a = t.addedNodes[n];
          (a !== o && a !== e) || i(t.target);
        }
      });
    });
  return a.observe(document, { childList: !0, subtree: !0 }), a;
}
function createDetachObserver(t, e, i) {
  const n = t.canvas,
    o = n && _getParentNode(n);
  if (!o) return;
  const a = new MutationObserver((t) => {
    t.forEach((t) => {
      for (let e = 0; e < t.removedNodes.length; e++)
        if (t.removedNodes[e] === n) {
          i();
          break;
        }
    });
  });
  return a.observe(o, { childList: !0 }), a;
}
function createResizeObserver(t, e, i) {
  const n = t.canvas,
    o = n && _getParentNode(n);
  if (!o) return;
  const a = throttled((t, e) => {
      const n = o.clientWidth;
      i(t, e), n < o.clientWidth && i();
    }, window),
    r = new ResizeObserver((t) => {
      const e = t[0],
        i = e.contentRect.width,
        n = e.contentRect.height;
      (0 === i && 0 === n) || a(i, n);
    });
  return r.observe(o), r;
}
function releaseObserver(t, e, i) {
  i && i.disconnect();
}
function createProxyAndListen(t, e, i) {
  const n = t.canvas,
    o = throttled((e) => {
      null !== t.ctx && i(fromNativeEvent(e, t));
    }, t);
  return addListener(n, e, o), o;
}
class DomPlatform extends BasePlatform {
  acquireContext(t, e) {
    const i = t && t.getContext && t.getContext('2d');
    return i && i.canvas === t ? (initCanvas(t, e), i) : null;
  }
  releaseContext(t) {
    const e = t.canvas;
    if (!e[EXPANDO_KEY]) return !1;
    const i = e[EXPANDO_KEY].initial;
    ['height', 'width'].forEach((t) => {
      const n = i[t];
      isNullOrUndef(n) ? e.removeAttribute(t) : e.setAttribute(t, n);
    });
    const n = i.style || {};
    return (
      Object.keys(n).forEach((t) => {
        e.style[t] = n[t];
      }),
      (e.width = e.width),
      delete e[EXPANDO_KEY],
      !0
    );
  }
  addEventListener(t, e, i) {
    this.removeEventListener(t, e);
    const n = t.$proxies || (t.$proxies = {}),
      o =
        {
          attach: createAttachObserver,
          detach: createDetachObserver,
          resize: createResizeObserver,
        }[e] || createProxyAndListen;
    n[e] = o(t, e, i);
  }
  removeEventListener(t, e) {
    const i = t.canvas,
      n = t.$proxies || (t.$proxies = {}),
      o = n[e];
    o &&
      ((
        {
          attach: releaseObserver,
          detach: releaseObserver,
          resize: releaseObserver,
        }[e] || removeListener
      )(i, e, o),
      (n[e] = void 0));
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  isAttached(t) {
    const e = _getParentNode(t);
    return !(!e || !_getParentNode(e));
  }
}
var platforms = Object.freeze({
  __proto__: null,
  BasePlatform: BasePlatform,
  BasicPlatform: BasicPlatform,
  DomPlatform: DomPlatform,
});
defaults.set('plugins', {});
class PluginService {
  constructor() {
    (this._plugins = []), (this._cacheId = 0);
  }
  register(t) {
    const e = this._plugins;
    [].concat(t).forEach((t) => {
      -1 === e.indexOf(t) && e.push(t);
    }),
      this._cacheId++;
  }
  unregister(t) {
    const e = this._plugins;
    [].concat(t).forEach((t) => {
      const i = e.indexOf(t);
      -1 !== i && e.splice(i, 1);
    }),
      this._cacheId++;
  }
  clear() {
    (this._plugins = []), this._cacheId++;
  }
  count() {
    return this._plugins.length;
  }
  getAll() {
    return this._plugins;
  }
  notify(t, e, i) {
    const n = this._descriptors(t),
      o = n.length;
    let a, r, s, l, c;
    for (a = 0; a < o; ++a)
      if (
        'function' == typeof (c = (s = (r = n[a]).plugin)[e]) &&
        ((l = [t].concat(i || [])).push(r.options), !1 === c.apply(s, l))
      )
        return !1;
    return !0;
  }
  _descriptors(t) {
    const e = t.$plugins || (t.$plugins = {});
    if (e.id === this._cacheId) return e.descriptors;
    const i = [],
      n = [],
      o = (t && t.config) || {},
      a = (o.options && o.options.plugins) || {};
    return (
      this._plugins.concat(o.plugins || []).forEach((t) => {
        if (-1 !== i.indexOf(t)) return;
        const e = t.id;
        let o = a[e];
        !1 !== o &&
          (!0 === o && (o = clone(defaults.plugins[e])),
          i.push(t),
          n.push({ plugin: t, options: o || {} }));
      }),
      (e.descriptors = n),
      (e.id = this._cacheId),
      n
    );
  }
  invalidate(t) {
    delete t.$plugins;
  }
}
var pluginsCore = new PluginService(),
  scaleService = {
    constructors: {},
    defaults: {},
    registerScale(t) {
      const e = t.id;
      (this.constructors[e] = t), (this.defaults[e] = clone(t.defaults));
    },
    getScaleConstructor(t) {
      return Object.prototype.hasOwnProperty.call(this.constructors, t)
        ? this.constructors[t]
        : void 0;
    },
    getScaleDefaults(t) {
      return Object.prototype.hasOwnProperty.call(this.defaults, t)
        ? merge({}, [defaults.scale, this.defaults[t]])
        : {};
    },
    updateScaleDefaults(t, e) {
      const i = this;
      Object.prototype.hasOwnProperty.call(i.defaults, t) &&
        (i.defaults[t] = Object.assign(i.defaults[t], e));
    },
    addScalesToLayout(t) {
      each(t.scales, (e) => {
        (e.fullWidth = e.options.fullWidth),
          (e.position = e.options.position),
          (e.weight = e.options.weight),
          layouts.addBox(t, e);
      });
    },
  },
  version = '3.0.0-alpha';
function mergeScaleConfig(t, e) {
  e = e || {};
  const i = defaults[t.type] || { scales: {} },
    n = e.scales || {},
    o = {},
    a = {};
  return (
    Object.keys(n).forEach((t) => {
      const e = t[0];
      (o[e] = o[e] || t), (a[t] = mergeIf({}, [n[t], i.scales[e]]));
    }),
    e.scale &&
      ((a[e.scale.id || 'r'] = mergeIf({}, [e.scale, i.scales.r])),
      (o.r = o.r || e.scale.id || 'r')),
    t.data.datasets.forEach((e) => {
      const i = (defaults[e.type || t.type] || { scales: {} }).scales || {};
      Object.keys(i).forEach((t) => {
        const r = e[t + 'AxisID'] || o[t] || t;
        (a[r] = a[r] || {}), mergeIf(a[r], [n[r], i[t]]);
      });
    }),
    Object.keys(a).forEach((t) => {
      const e = a[t];
      mergeIf(e, scaleService.getScaleDefaults(e.type));
    }),
    a
  );
}
function mergeConfig(...t) {
  return merge({}, t, {
    merger(t, e, i, n) {
      'scales' !== t && 'scale' !== t && _merger(t, e, i, n);
    },
  });
}
function initConfig(t) {
  const e = ((t = t || {}).data = t.data || { datasets: [], labels: [] });
  (e.datasets = e.datasets || []), (e.labels = e.labels || []);
  const i = mergeScaleConfig(t, t.options);
  return (
    (t.options = mergeConfig(defaults, defaults[t.type], t.options || {})),
    (t.options.scales = i),
    t
  );
}
function isAnimationDisabled(t) {
  return !t.animation;
}
function updateConfig(t) {
  let e = t.options;
  each(t.scales, (e) => {
    layouts.removeBox(t, e);
  });
  const i = mergeScaleConfig(t.config, e);
  (e = mergeConfig(defaults, defaults[t.config.type], e)),
    (t.options = t.config.options = e),
    (t.options.scales = i),
    (t._animationsDisabled = isAnimationDisabled(e));
}
const KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];
function positionIsHorizontal(t, e) {
  return (
    'top' === t ||
    'bottom' === t ||
    (-1 === KNOWN_POSITIONS.indexOf(t) && 'x' === e)
  );
}
function compare2Level(t, e) {
  return function (i, n) {
    return i[t] === n[t] ? i[e] - n[e] : i[t] - n[t];
  };
}
function onAnimationsComplete(t) {
  const e = t.chart,
    i = e.options.animation;
  pluginsCore.notify(e, 'afterRender'), callback(i && i.onComplete, [t], e);
}
function onAnimationProgress(t) {
  const e = t.chart,
    i = e.options.animation;
  callback(i && i.onProgress, [t], e);
}
function isDomSupported() {
  return 'undefined' != typeof window && 'undefined' != typeof document;
}
function getCanvas(t) {
  return (
    isDomSupported() && 'string' == typeof t
      ? (t = document.getElementById(t))
      : t.length && (t = t[0]),
    t && t.canvas && (t = t.canvas),
    t
  );
}
function computeNewSize(t, e, i, n) {
  return (
    (void 0 !== e && void 0 !== i) ||
      ((e = getMaximumWidth(t)), (i = getMaximumHeight(t))),
    {
      width: (e = Math.max(0, Math.floor(e))),
      height: Math.max(0, Math.floor(n ? e / n : i)),
    }
  );
}
class Chart {
  constructor(t, e) {
    const i = this;
    e = initConfig(e);
    const n = getCanvas(t);
    this.platform = i._initializePlatform(n, e);
    const o = i.platform.acquireContext(n, e),
      a = o && o.canvas,
      r = a && a.height,
      s = a && a.width;
    (this.id = uid()),
      (this.ctx = o),
      (this.canvas = a),
      (this.config = e),
      (this.width = s),
      (this.height = r),
      (this.aspectRatio = r ? s / r : null),
      (this.options = e.options),
      (this._bufferedRender = !1),
      (this._layers = []),
      (this._metasets = []),
      (this.boxes = []),
      (this.currentDevicePixelRatio = void 0),
      (this.chartArea = void 0),
      (this.data = void 0),
      (this._active = []),
      (this._lastEvent = void 0),
      (this._listeners = {}),
      (this._sortedMetasets = []),
      (this._updating = !1),
      (this.scales = {}),
      (this.scale = void 0),
      (this.$plugins = void 0),
      (this.$proxies = {}),
      (this._hiddenIndices = {}),
      (this.attached = !0),
      (Chart.instances[i.id] = i),
      Object.defineProperty(i, 'data', {
        get: () => i.config.data,
        set(t) {
          i.config.data = t;
        },
      }),
      o && a
        ? (animator.listen(i, 'complete', onAnimationsComplete),
          animator.listen(i, 'progress', onAnimationProgress),
          i._initialize(),
          i.attached && i.update())
        : console.error(
            "Failed to create chart: can't acquire context from the given item",
          );
  }
  _initialize() {
    const t = this;
    return (
      pluginsCore.notify(t, 'beforeInit'),
      t.options.responsive
        ? t.resize(!0)
        : retinaScale(t, t.options.devicePixelRatio),
      t.bindEvents(),
      pluginsCore.notify(t, 'afterInit'),
      t
    );
  }
  _initializePlatform(t, e) {
    return e.platform
      ? new e.platform()
      : !isDomSupported() ||
        ('undefined' != typeof OffscreenCanvas && t instanceof OffscreenCanvas)
      ? new BasicPlatform()
      : new DomPlatform();
  }
  clear() {
    return clear(this), this;
  }
  stop() {
    return animator.stop(this), this;
  }
  resize(t, e, i) {
    const n = this,
      o = n.options,
      a = n.canvas,
      r = computeNewSize(a, e, i, o.maintainAspectRatio && n.aspectRatio),
      s = n.currentDevicePixelRatio,
      l = o.devicePixelRatio || n.platform.getDevicePixelRatio();
    (n.width === r.width && n.height === r.height && s === l) ||
      ((a.width = n.width = r.width),
      (a.height = n.height = r.height),
      a.style &&
        ((a.style.width = r.width + 'px'), (a.style.height = r.height + 'px')),
      retinaScale(n, l),
      t ||
        (pluginsCore.notify(n, 'resize', [r]),
        o.onResize && o.onResize(n, r),
        n.update(n.attached && 'resize')));
  }
  ensureScalesHaveIDs() {
    const t = this.options,
      e = t.scales || {},
      i = t.scale;
    each(e, (t, e) => {
      t.id = e;
    }),
      i && (i.id = i.id || 'scale');
  }
  buildOrUpdateScales() {
    const t = this,
      e = t.options.scales,
      i = t.scales || {},
      n = Object.keys(i).reduce((t, e) => ((t[e] = !1), t), {});
    let o = [];
    e &&
      (o = o.concat(
        Object.keys(e).map((t) => {
          const i = e[t],
            n = 'r' === t.charAt(0).toLowerCase(),
            o = 'x' === t.charAt(0).toLowerCase();
          return {
            options: i,
            dposition: n ? 'chartArea' : o ? 'bottom' : 'left',
            dtype: n ? 'radialLinear' : o ? 'category' : 'linear',
          };
        }),
      )),
      each(o, (e) => {
        const o = e.options,
          a = o.id,
          r = valueOrDefault(o.type, e.dtype);
        (void 0 !== o.position &&
          positionIsHorizontal(o.position, o.axis || a[0]) ===
            positionIsHorizontal(e.dposition)) ||
          (o.position = e.dposition),
          (n[a] = !0);
        let s = null;
        if (a in i && i[a].type === r) s = i[a];
        else {
          const e = scaleService.getScaleConstructor(r);
          if (!e) return;
          (s = new e({ id: a, type: r, ctx: t.ctx, chart: t })), (i[s.id] = s);
        }
        s.init(o), e.isDefault && (t.scale = s);
      }),
      each(n, (t, e) => {
        t || delete i[e];
      }),
      (t.scales = i),
      scaleService.addScalesToLayout(this);
  }
  _updateMetasetIndex(t, e) {
    const i = this._metasets,
      n = t.index;
    n !== e && ((i[n] = i[e]), (i[e] = t), (t.index = e));
  }
  _updateMetasets() {
    const t = this,
      e = t._metasets,
      i = t.data.datasets.length,
      n = e.length;
    if (n > i) {
      for (let e = i; e < n; ++e) t._destroyDatasetMeta(e);
      e.splice(i, n - i);
    }
    t._sortedMetasets = e.slice(0).sort(compare2Level('order', 'index'));
  }
  buildOrUpdateControllers() {
    const t = this,
      e = [],
      i = t.data.datasets;
    let n, o;
    for (n = 0, o = i.length; n < o; n++) {
      const o = i[n];
      let a = t.getDatasetMeta(n);
      const r = o.type || t.config.type;
      if (
        (a.type &&
          a.type !== r &&
          (t._destroyDatasetMeta(n), (a = t.getDatasetMeta(n))),
        (a.type = r),
        (a.order = o.order || 0),
        t._updateMetasetIndex(a, n),
        (a.label = '' + o.label),
        (a.visible = t.isDatasetVisible(n)),
        a.controller)
      )
        a.controller.updateIndex(n), a.controller.linkScales();
      else {
        const i = controllers[a.type];
        if (void 0 === i)
          throw new Error('"' + a.type + '" is not a chart type.');
        (a.controller = new i(t, n)), e.push(a.controller);
      }
    }
    return t._updateMetasets(), e;
  }
  _resetElements() {
    const t = this;
    each(
      t.data.datasets,
      (e, i) => {
        t.getDatasetMeta(i).controller.reset();
      },
      t,
    );
  }
  reset() {
    this._resetElements(), pluginsCore.notify(this, 'reset');
  }
  update(t) {
    const e = this;
    let i, n;
    if (
      ((e._updating = !0),
      updateConfig(e),
      e.ensureScalesHaveIDs(),
      e.buildOrUpdateScales(),
      pluginsCore.invalidate(e),
      !1 === pluginsCore.notify(e, 'beforeUpdate'))
    )
      return;
    const o = e.buildOrUpdateControllers();
    for (i = 0, n = e.data.datasets.length; i < n; i++)
      e.getDatasetMeta(i).controller.buildOrUpdateElements();
    e._updateLayout(),
      e.options.animation &&
        each(o, (t) => {
          t.reset();
        }),
      e._updateDatasets(t),
      pluginsCore.notify(e, 'afterUpdate'),
      e._layers.sort(compare2Level('z', '_idx')),
      e._lastEvent && e._eventHandler(e._lastEvent, !0),
      e.render(),
      (e._updating = !1);
  }
  _updateLayout() {
    const t = this;
    !1 !== pluginsCore.notify(t, 'beforeLayout') &&
      (layouts.update(t, t.width, t.height),
      (t._layers = []),
      each(
        t.boxes,
        (e) => {
          e.configure && e.configure(), t._layers.push(...e._layers());
        },
        t,
      ),
      t._layers.forEach((t, e) => {
        t._idx = e;
      }),
      pluginsCore.notify(t, 'afterLayout'));
  }
  _updateDatasets(t) {
    const e = this,
      i = 'function' == typeof t;
    if (!1 !== pluginsCore.notify(e, 'beforeDatasetsUpdate')) {
      for (let n = 0, o = e.data.datasets.length; n < o; ++n)
        e._updateDataset(n, i ? t({ datasetIndex: n }) : t);
      pluginsCore.notify(e, 'afterDatasetsUpdate');
    }
  }
  _updateDataset(t, e) {
    const i = this.getDatasetMeta(t),
      n = { meta: i, index: t, mode: e };
    !1 !== pluginsCore.notify(this, 'beforeDatasetUpdate', [n]) &&
      (i.controller._update(e),
      pluginsCore.notify(this, 'afterDatasetUpdate', [n]));
  }
  render() {
    const t = this,
      e = t.options.animation;
    if (!1 === pluginsCore.notify(t, 'beforeRender')) return;
    animator.has(t)
      ? t.attached && !animator.running(t) && animator.start(t)
      : (t.draw(),
        pluginsCore.notify(t, 'afterRender'),
        callback(e && e.onComplete, [], t));
  }
  draw() {
    const t = this;
    let e;
    if ((t.clear(), t.width <= 0 || t.height <= 0)) return;
    if (!1 === pluginsCore.notify(t, 'beforeDraw')) return;
    const i = t._layers;
    for (e = 0; e < i.length && i[e].z <= 0; ++e) i[e].draw(t.chartArea);
    for (t._drawDatasets(); e < i.length; ++e) i[e].draw(t.chartArea);
    pluginsCore.notify(t, 'afterDraw');
  }
  _getSortedDatasetMetas(t) {
    const e = this._sortedMetasets,
      i = [];
    let n, o;
    for (n = 0, o = e.length; n < o; ++n) {
      const o = e[n];
      (t && !o.visible) || i.push(o);
    }
    return i;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(!0);
  }
  _drawDatasets() {
    const t = this;
    if (!1 === pluginsCore.notify(t, 'beforeDatasetsDraw')) return;
    const e = t.getSortedVisibleDatasetMetas();
    for (let i = e.length - 1; i >= 0; --i) t._drawDataset(e[i]);
    pluginsCore.notify(t, 'afterDatasetsDraw');
  }
  _drawDataset(t) {
    const e = this,
      i = e.ctx,
      n = t._clip,
      o = e.chartArea,
      a = { meta: t, index: t.index };
    !1 !== pluginsCore.notify(e, 'beforeDatasetDraw', [a]) &&
      (clipArea(i, {
        left: !1 === n.left ? 0 : o.left - n.left,
        right: !1 === n.right ? e.width : o.right + n.right,
        top: !1 === n.top ? 0 : o.top - n.top,
        bottom: !1 === n.bottom ? e.height : o.bottom + n.bottom,
      }),
      t.controller.draw(),
      unclipArea(i),
      pluginsCore.notify(e, 'afterDatasetDraw', [a]));
  }
  getElementAtEvent(t) {
    return Interaction.modes.nearest(this, t, { intersect: !0 });
  }
  getElementsAtEvent(t) {
    return Interaction.modes.index(this, t, { intersect: !0 });
  }
  getElementsAtXAxis(t) {
    return Interaction.modes.index(this, t, { intersect: !1 });
  }
  getElementsAtEventForMode(t, e, i, n) {
    const o = Interaction.modes[e];
    return 'function' == typeof o ? o(this, t, i, n) : [];
  }
  getDatasetAtEvent(t) {
    return Interaction.modes.dataset(this, t, { intersect: !0 });
  }
  getDatasetMeta(t) {
    const e = this.data.datasets[t],
      i = this._metasets;
    let n = i.filter((t) => t._dataset === e).pop();
    return (
      n ||
        (n = i[t] =
          {
            type: null,
            data: [],
            dataset: null,
            controller: null,
            hidden: null,
            xAxisID: null,
            yAxisID: null,
            order: e.order || 0,
            index: t,
            _dataset: e,
            _parsed: [],
            _sorted: !1,
          }),
      n
    );
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(t) {
    const e = this.getDatasetMeta(t);
    return 'boolean' == typeof e.hidden
      ? !e.hidden
      : !this.data.datasets[t].hidden;
  }
  setDatasetVisibility(t, e) {
    this.getDatasetMeta(t).hidden = !e;
  }
  toggleDataVisibility(t) {
    this._hiddenIndices[t] = !this._hiddenIndices[t];
  }
  getDataVisibility(t) {
    return !this._hiddenIndices[t];
  }
  _updateDatasetVisibility(t, e) {
    const i = e ? 'show' : 'hide',
      n = this.getDatasetMeta(t),
      o = n.controller._resolveAnimations(void 0, i);
    this.setDatasetVisibility(t, e),
      o.update(n, { visible: e }),
      this.update((e) => (e.datasetIndex === t ? i : void 0));
  }
  hide(t) {
    this._updateDatasetVisibility(t, !1);
  }
  show(t) {
    this._updateDatasetVisibility(t, !0);
  }
  _destroyDatasetMeta(t) {
    const e = this,
      i = e._metasets && e._metasets[t];
    i && (i.controller._destroy(), delete e._metasets[t]);
  }
  destroy() {
    const t = this,
      e = t.canvas;
    let i, n;
    for (
      t.stop(), animator.remove(t), i = 0, n = t.data.datasets.length;
      i < n;
      ++i
    )
      t._destroyDatasetMeta(i);
    e &&
      (t.unbindEvents(),
      clear(t),
      t.platform.releaseContext(t.ctx),
      (t.canvas = null),
      (t.ctx = null)),
      pluginsCore.notify(t, 'destroy'),
      delete Chart.instances[t.id];
  }
  toBase64Image(...t) {
    return this.canvas.toDataURL(...t);
  }
  bindEvents() {
    const t = this,
      e = t._listeners,
      i = t.platform,
      n = (n, o) => {
        i.addEventListener(t, n, o), (e[n] = o);
      },
      o = (n, o) => {
        e[n] && (i.removeEventListener(t, n, o), delete e[n]);
      };
    let a = function (e) {
      t._eventHandler(e);
    };
    if ((each(t.options.events, (t) => n(t, a)), t.options.responsive)) {
      let e;
      a = (e, i) => {
        t.canvas && t.resize(!1, e, i);
      };
      const r = () => {
        o('attach', r),
          t.resize(),
          (t.attached = !0),
          n('resize', a),
          n('detach', e);
      };
      (e = () => {
        (t.attached = !1), o('resize', a), n('attach', r);
      }),
        i.isAttached(t.canvas) ? r() : e();
    } else t.attached = !0;
  }
  unbindEvents() {
    const t = this,
      e = t._listeners;
    e &&
      (delete t._listeners,
      each(e, (e, i) => {
        t.platform.removeEventListener(t, i, e);
      }));
  }
  updateHoverStyle(t, e, i) {
    const n = i ? 'set' : 'remove';
    let o, a, r, s;
    for (
      'dataset' === e &&
        (o = this.getDatasetMeta(t[0].datasetIndex)).controller[
          '_' + n + 'DatasetHoverStyle'
        ](),
        r = 0,
        s = t.length;
      r < s;
      ++r
    )
      (a = t[r]) &&
        this.getDatasetMeta(a.datasetIndex).controller[n + 'HoverStyle'](
          a.element,
          a.datasetIndex,
          a.index,
        );
  }
  _updateHoverStyles(t, e) {
    const i = this,
      n = (i.options || {}).hover;
    e.length && i.updateHoverStyle(e, n.mode, !1),
      t.length && n.mode && i.updateHoverStyle(t, n.mode, !0);
  }
  _eventHandler(t, e) {
    const i = this;
    if (!1 !== pluginsCore.notify(i, 'beforeEvent', [t, e]))
      return (
        i._handleEvent(t, e),
        pluginsCore.notify(i, 'afterEvent', [t, e]),
        i.render(),
        i
      );
  }
  _handleEvent(t, e) {
    const i = this,
      n = i._active || [],
      o = i.options,
      a = o.hover,
      r = e;
    let s = [],
      l = !1;
    return (
      'mouseout' === t.type
        ? (i._lastEvent = null)
        : ((s = i.getElementsAtEventForMode(t, a.mode, a, r)),
          (i._lastEvent = 'click' === t.type ? i._lastEvent : t)),
      callback(o.onHover || o.hover.onHover, [t, s, i], i),
      ('mouseup' !== t.type && 'click' !== t.type) ||
        (_isPointInArea(t, i.chartArea) && callback(o.onClick, [t, s, i], i)),
      ((l = !_elementsEqual(s, n)) || e) &&
        ((i._active = s), i._updateHoverStyles(s, n)),
      l
    );
  }
}
(Chart.version = version), (Chart.instances = {});
const getRightToLeftAdapter = function (t, e) {
    return {
      x: (i) => t + t + e - i,
      setWidth(t) {
        e = t;
      },
      textAlign: (t) => ('center' === t ? t : 'right' === t ? 'left' : 'right'),
      xPlus: (t, e) => t - e,
      leftForLtr: (t, e) => t - e,
    };
  },
  getLeftToRightAdapter = function () {
    return {
      x: (t) => t,
      setWidth(t) {},
      textAlign: (t) => t,
      xPlus: (t, e) => t + e,
      leftForLtr: (t, e) => t,
    };
  };
function getRtlAdapter(t, e, i) {
  return t ? getRightToLeftAdapter(e, i) : getLeftToRightAdapter();
}
function overrideTextDirection(t, e) {
  let i, n;
  ('ltr' !== e && 'rtl' !== e) ||
    ((n = [
      (i = t.canvas.style).getPropertyValue('direction'),
      i.getPropertyPriority('direction'),
    ]),
    i.setProperty('direction', e, 'important'),
    (t.prevTextDirection = n));
}
function restoreTextDirection(t, e) {
  void 0 !== e &&
    (delete t.prevTextDirection,
    t.canvas.style.setProperty('direction', e[0], e[1]));
}
var rtl = Object.freeze({
    __proto__: null,
    getRtlAdapter: getRtlAdapter,
    overrideTextDirection: overrideTextDirection,
    restoreTextDirection: restoreTextDirection,
  }),
  helpers = {
    ...coreHelpers,
    canvas: canvas,
    curve: curve,
    dom: dom,
    easing: { effects: effects },
    options: options,
    math: math,
    rtl: rtl,
    requestAnimFrame: requestAnimFrame,
    fontString: fontString,
    color: color,
    getHoverColor: getHoverColor,
  };
function abstract() {
  throw new Error(
    'This method is not implemented: either no adapter can be found or an incomplete integration was provided.',
  );
}
class DateAdapter {
  constructor(t) {
    this.options = t || {};
  }
  formats() {
    return abstract();
  }
  parse(t, e) {
    return abstract();
  }
  format(t, e) {
    return abstract();
  }
  add(t, e, i) {
    return abstract();
  }
  diff(t, e, i) {
    return abstract();
  }
  startOf(t, e, i) {
    return abstract();
  }
  endOf(t, e) {
    return abstract();
  }
}
DateAdapter.override = function (t) {
  Object.assign(DateAdapter.prototype, t);
};
var _adapters = { _date: DateAdapter };
const formatters = {
  values: (t) => (isArray(t) ? t : '' + t),
  numeric(t, e, i) {
    if (0 === t) return '0';
    const n = this.chart.options.locale,
      o = Math.max(Math.abs(i[0].value), Math.abs(i[i.length - 1].value));
    let a;
    (o < 1e-4 || o > 1e15) && (a = 'scientific');
    let r = i.length > 3 ? i[2].value - i[1].value : i[1].value - i[0].value;
    Math.abs(r) > 1 && t !== Math.floor(t) && (r = t - Math.floor(t));
    const s = log10(Math.abs(r)),
      l = Math.max(Math.min(-1 * Math.floor(s), 20), 0),
      c = { notation: a, minimumFractionDigits: l, maximumFractionDigits: l };
    return (
      Object.assign(c, this.options.ticks.format),
      new Intl.NumberFormat(n, c).format(t)
    );
  },
  logarithmic: function (t, e, i) {
    if (0 === t) return '0';
    const n = t / Math.pow(10, Math.floor(log10(t)));
    return 1 === n || 2 === n || 5 === n
      ? formatters.numeric.call(this, t, e, i)
      : '';
  },
};
var Ticks = { formatters: formatters };
function sample(t, e) {
  const i = [],
    n = t.length / e,
    o = t.length;
  let a = 0;
  for (; a < o; a += n) i.push(t[Math.floor(a)]);
  return i;
}
function getPixelForGridLine(t, e, i) {
  const n = t.ticks.length,
    o = Math.min(e, n - 1),
    a = t._startPixel,
    r = t._endPixel;
  let s,
    l = t.getPixelForTick(o);
  if (
    !(
      i &&
      ((s =
        1 === n
          ? Math.max(l - a, r - l)
          : 0 === e
          ? (t.getPixelForTick(1) - l) / 2
          : (l - t.getPixelForTick(o - 1)) / 2),
      (l += o < e ? s : -s) < a - 1e-6 || l > r + 1e-6)
    )
  )
    return l;
}
function garbageCollect(t, e) {
  each(t, (t) => {
    const i = t.gc,
      n = i.length / 2;
    let o;
    if (n > e) {
      for (o = 0; o < n; ++o) delete t.data[i[o]];
      i.splice(0, n);
    }
  });
}
function getTickMarkLength(t) {
  return t.drawTicks ? t.tickMarkLength : 0;
}
function getScaleLabelHeight(t) {
  if (!t.display) return 0;
  const e = toFont(t.font),
    i = toPadding(t.padding);
  return e.lineHeight + i.height;
}
function getEvenSpacing(t) {
  const e = t.length;
  let i, n;
  if (e < 2) return !1;
  for (n = t[0], i = 1; i < e; ++i) if (t[i] - t[i - 1] !== n) return !1;
  return n;
}
function calculateSpacing(t, e, i) {
  const n = getEvenSpacing(t),
    o = e.length / i;
  if (!n) return Math.max(o, 1);
  const a = _factorize(n);
  for (let t = 0, e = a.length - 1; t < e; t++) {
    const e = a[t];
    if (e > o) return e;
  }
  return Math.max(o, 1);
}
function getMajorIndices(t) {
  const e = [];
  let i, n;
  for (i = 0, n = t.length; i < n; i++) t[i].major && e.push(i);
  return e;
}
function skipMajors(t, e, i, n) {
  let o,
    a = 0,
    r = i[0];
  for (n = Math.ceil(n), o = 0; o < t.length; o++)
    o === r && (e.push(t[o]), (r = i[++a * n]));
}
function skip(t, e, i, n, o) {
  const a = valueOrDefault(n, 0),
    r = Math.min(valueOrDefault(o, t.length), t.length);
  let s,
    l,
    c,
    d = 0;
  for (
    i = Math.ceil(i), o && (i = (s = o - n) / Math.floor(s / i)), c = a;
    c < 0;

  )
    d++, (c = Math.round(a + d * i));
  for (l = Math.max(a, 0); l < r; l++)
    l === c && (e.push(t[l]), d++, (c = Math.round(a + d * i)));
}
defaults.set('scale', {
  display: !0,
  offset: !1,
  reverse: !1,
  beginAtZero: !1,
  gridLines: {
    display: !0,
    color: 'rgba(0,0,0,0.1)',
    lineWidth: 1,
    drawBorder: !0,
    drawOnChartArea: !0,
    drawTicks: !0,
    tickMarkLength: 10,
    offsetGridLines: !1,
    borderDash: [],
    borderDashOffset: 0,
  },
  scaleLabel: { display: !1, labelString: '', padding: { top: 4, bottom: 4 } },
  ticks: {
    minRotation: 0,
    maxRotation: 50,
    mirror: !1,
    lineWidth: 0,
    strokeStyle: '',
    padding: 0,
    display: !0,
    autoSkip: !0,
    autoSkipPadding: 0,
    labelOffset: 0,
    callback: Ticks.formatters.values,
    minor: {},
    major: {},
  },
});
class Scale extends Element {
  constructor(t) {
    super(),
      (this.id = t.id),
      (this.type = t.type),
      (this.options = void 0),
      (this.ctx = t.ctx),
      (this.chart = t.chart),
      (this.top = void 0),
      (this.bottom = void 0),
      (this.left = void 0),
      (this.right = void 0),
      (this.width = void 0),
      (this.height = void 0),
      (this._margins = { left: 0, right: 0, top: 0, bottom: 0 }),
      (this.maxWidth = void 0),
      (this.maxHeight = void 0),
      (this.paddingTop = void 0),
      (this.paddingBottom = void 0),
      (this.paddingLeft = void 0),
      (this.paddingRight = void 0),
      (this.axis = void 0),
      (this.labelRotation = void 0),
      (this.min = void 0),
      (this.max = void 0),
      (this.ticks = []),
      (this._gridLineItems = null),
      (this._labelItems = null),
      (this._labelSizes = null),
      (this._length = 0),
      (this._longestTextCache = {}),
      (this._startPixel = void 0),
      (this._endPixel = void 0),
      (this._reversePixels = !1),
      (this._userMax = void 0),
      (this._userMin = void 0),
      (this._ticksLength = 0),
      (this._borderValue = 0);
  }
  init(t) {
    const e = this;
    (e.options = t),
      (e.axis = e.isHorizontal() ? 'x' : 'y'),
      (e._userMin = e.parse(t.min)),
      (e._userMax = e.parse(t.max));
  }
  parse(t, e) {
    return t;
  }
  parseObject(t, e, i) {
    return void 0 !== t[e] ? this.parse(t[e], i) : null;
  }
  getUserBounds() {
    let t = this._userMin,
      e = this._userMax;
    return (
      (isNullOrUndef(t) || isNaN(t)) && (t = Number.POSITIVE_INFINITY),
      (isNullOrUndef(e) || isNaN(e)) && (e = Number.NEGATIVE_INFINITY),
      {
        min: t,
        max: e,
        minDefined: isNumberFinite(t),
        maxDefined: isNumberFinite(e),
      }
    );
  }
  getMinMax(t) {
    const e = this;
    let i,
      { min: n, max: o, minDefined: a, maxDefined: r } = e.getUserBounds();
    if (a && r) return { min: n, max: o };
    const s = e.getMatchingVisibleMetas();
    for (let l = 0, c = s.length; l < c; ++l)
      (i = s[l].controller.getMinMax(e, t)),
        a || (n = Math.min(n, i.min)),
        r || (o = Math.max(o, i.max));
    return { min: n, max: o };
  }
  invalidateCaches() {}
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0,
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const t = this.chart.data;
    return (
      this.options.labels ||
      (this.isHorizontal() ? t.xLabels : t.yLabels) ||
      t.labels ||
      []
    );
  }
  beforeUpdate() {
    callback(this.options.beforeUpdate, [this]);
  }
  update(t, e, i) {
    const n = this,
      o = n.options.ticks,
      a = o.sampleSize;
    n.beforeUpdate(),
      (n.maxWidth = t),
      (n.maxHeight = e),
      (n._margins = Object.assign({ left: 0, right: 0, top: 0, bottom: 0 }, i)),
      (n.ticks = null),
      (n._labelSizes = null),
      (n._gridLineItems = null),
      (n._labelItems = null),
      n.beforeSetDimensions(),
      n.setDimensions(),
      n.afterSetDimensions(),
      n.beforeDataLimits(),
      n.determineDataLimits(),
      n.afterDataLimits(),
      n.beforeBuildTicks(),
      (n.ticks = n.buildTicks() || []),
      n.afterBuildTicks();
    const r = a < n.ticks.length;
    n._convertTicksToLabels(r ? sample(n.ticks, a) : n.ticks),
      n.configure(),
      n.beforeCalculateLabelRotation(),
      n.calculateLabelRotation(),
      n.afterCalculateLabelRotation(),
      n.beforeFit(),
      n.fit(),
      n.afterFit(),
      (n.ticks =
        o.display && (o.autoSkip || 'auto' === o.source)
          ? n._autoSkip(n.ticks)
          : n.ticks),
      r && n._convertTicksToLabels(n.ticks),
      n.afterUpdate();
  }
  configure() {
    const t = this;
    let e,
      i,
      n = t.options.reverse;
    t.isHorizontal()
      ? ((e = t.left), (i = t.right))
      : ((e = t.top), (i = t.bottom), (n = !n)),
      (t._startPixel = e),
      (t._endPixel = i),
      (t._reversePixels = n),
      (t._length = i - e);
  }
  afterUpdate() {
    callback(this.options.afterUpdate, [this]);
  }
  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [this]);
  }
  setDimensions() {
    const t = this;
    t.isHorizontal()
      ? ((t.width = t.maxWidth), (t.left = 0), (t.right = t.width))
      : ((t.height = t.maxHeight), (t.top = 0), (t.bottom = t.height)),
      (t.paddingLeft = 0),
      (t.paddingTop = 0),
      (t.paddingRight = 0),
      (t.paddingBottom = 0);
  }
  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [this]);
  }
  beforeDataLimits() {
    callback(this.options.beforeDataLimits, [this]);
  }
  determineDataLimits() {}
  afterDataLimits() {
    callback(this.options.afterDataLimits, [this]);
  }
  beforeBuildTicks() {
    callback(this.options.beforeBuildTicks, [this]);
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    callback(this.options.afterBuildTicks, [this]);
  }
  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [this]);
  }
  generateTickLabels(t) {
    const e = this,
      i = e.options.ticks;
    let n, o, a;
    for (n = 0, o = t.length; n < o; n++)
      (a = t[n]).label = callback(i.callback, [a.value, n, t], e);
  }
  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [this]);
  }
  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [this]);
  }
  calculateLabelRotation() {
    const t = this,
      e = t.options,
      i = e.ticks,
      n = t.ticks.length,
      o = i.minRotation || 0,
      a = i.maxRotation;
    let r,
      s,
      l,
      c = o;
    if (!t._isVisible() || !i.display || o >= a || n <= 1 || !t.isHorizontal())
      return void (t.labelRotation = o);
    const d = t._getLabelSizes(),
      h = d.widest.width,
      u = d.highest.height - d.highest.offset,
      g = Math.min(t.maxWidth, t.chart.width - h);
    h + 6 > (r = e.offset ? t.maxWidth / n : g / (n - 1)) &&
      ((r = g / (n - (e.offset ? 0.5 : 1))),
      (s =
        t.maxHeight -
        getTickMarkLength(e.gridLines) -
        i.padding -
        getScaleLabelHeight(e.scaleLabel)),
      (l = Math.sqrt(h * h + u * u)),
      (c = toDegrees(
        Math.min(
          Math.asin(Math.min((d.highest.height + 6) / r, 1)),
          Math.asin(Math.min(s / l, 1)) - Math.asin(u / l),
        ),
      )),
      (c = Math.max(o, Math.min(a, c)))),
      (t.labelRotation = c);
  }
  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [this]);
  }
  beforeFit() {
    callback(this.options.beforeFit, [this]);
  }
  fit() {
    const t = this,
      e = { width: 0, height: 0 },
      i = t.chart,
      n = t.options,
      o = n.ticks,
      a = n.scaleLabel,
      r = n.gridLines,
      s = t._isVisible(),
      l = 'top' !== n.position && 'x' === t.axis,
      c = t.isHorizontal();
    if (
      (c
        ? (e.width = t.maxWidth)
        : s && (e.width = getTickMarkLength(r) + getScaleLabelHeight(a)),
      c
        ? s && (e.height = getTickMarkLength(r) + getScaleLabelHeight(a))
        : (e.height = t.maxHeight),
      o.display && s && t.ticks.length)
    ) {
      const i = t._getLabelSizes(),
        n = i.first,
        a = i.last,
        r = i.widest,
        s = i.highest,
        d = 0.8 * s.offset,
        h = o.padding;
      if (c) {
        const i = 0 !== t.labelRotation,
          o = toRadians(t.labelRotation),
          c = Math.cos(o),
          u = Math.sin(o),
          g = u * r.width + c * (s.height - (i ? s.offset : 0)) + (i ? 0 : d);
        e.height = Math.min(t.maxHeight, e.height + g + h);
        const p = t.getPixelForTick(0) - t.left,
          f = t.right - t.getPixelForTick(t.ticks.length - 1);
        let m, b;
        i
          ? ((m = l ? c * n.width + u * n.offset : u * (n.height - n.offset)),
            (b = l ? u * (a.height - a.offset) : c * a.width + u * a.offset))
          : ((m = n.width / 2), (b = a.width / 2)),
          (t.paddingLeft =
            Math.max(((m - p) * t.width) / (t.width - p), 0) + 3),
          (t.paddingRight =
            Math.max(((b - f) * t.width) / (t.width - f), 0) + 3);
      } else {
        const i = o.mirror ? 0 : r.width + h + d;
        (e.width = Math.min(t.maxWidth, e.width + i)),
          (t.paddingTop = n.height / 2),
          (t.paddingBottom = a.height / 2);
      }
    }
    t._handleMargins(),
      c
        ? ((t.width = t._length = i.width - t._margins.left - t._margins.right),
          (t.height = e.height))
        : ((t.width = e.width),
          (t.height = t._length =
            i.height - t._margins.top - t._margins.bottom));
  }
  _handleMargins() {
    const t = this;
    t._margins &&
      ((t._margins.left = Math.max(t.paddingLeft, t._margins.left)),
      (t._margins.top = Math.max(t.paddingTop, t._margins.top)),
      (t._margins.right = Math.max(t.paddingRight, t._margins.right)),
      (t._margins.bottom = Math.max(t.paddingBottom, t._margins.bottom)));
  }
  afterFit() {
    callback(this.options.afterFit, [this]);
  }
  isHorizontal() {
    const { axis: t, position: e } = this.options;
    return 'top' === e || 'bottom' === e || 'x' === t;
  }
  isFullWidth() {
    return this.options.fullWidth;
  }
  _convertTicksToLabels(t) {
    this.beforeTickToLabelConversion(),
      this.generateTickLabels(t),
      this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    const t = this;
    let e = t._labelSizes;
    return e || (t._labelSizes = e = t._computeLabelSizes()), e;
  }
  _computeLabelSizes() {
    const t = this,
      e = t.ctx,
      i = t._longestTextCache,
      n = t.options.ticks.sampleSize,
      o = [],
      a = [],
      r = [];
    let s = t.ticks;
    n < s.length && (s = sample(s, n));
    const l = s.length;
    let c, d, h, u, g, p, f, m, b, x, _;
    for (c = 0; c < l; ++c) {
      if (
        ((u = s[c].label),
        (g = t._resolveTickFontOptions(c)),
        (e.font = p = g.string),
        (f = i[p] = i[p] || { data: {}, gc: [] }),
        (m = g.lineHeight),
        (b = x = 0),
        isNullOrUndef(u) || isArray(u))
      ) {
        if (isArray(u))
          for (d = 0, h = u.length; d < h; ++d)
            isNullOrUndef((_ = u[d])) ||
              isArray(_) ||
              ((b = _measureText(e, f.data, f.gc, b, _)), (x += m));
      } else (b = _measureText(e, f.data, f.gc, b, u)), (x = m);
      o.push(b), a.push(x), r.push(m / 2);
    }
    garbageCollect(i, l);
    const y = o.indexOf(Math.max.apply(null, o)),
      v = a.indexOf(Math.max.apply(null, a));
    function M(t) {
      return { width: o[t] || 0, height: a[t] || 0, offset: r[t] || 0 };
    }
    return { first: M(0), last: M(l - 1), widest: M(y), highest: M(v) };
  }
  getLabelForValue(t) {
    return t;
  }
  getPixelForValue(t) {
    return NaN;
  }
  getValueForPixel(t) {}
  getPixelForTick(t) {
    const e = this.ticks;
    return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);
  }
  getPixelForDecimal(t) {
    return (
      this._reversePixels && (t = 1 - t), this._startPixel + t * this._length
    );
  }
  getDecimalForPixel(t) {
    const e = (t - this._startPixel) / this._length;
    return this._reversePixels ? 1 - e : e;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min: t, max: e } = this;
    return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0;
  }
  _autoSkip(t) {
    const e = this.options.ticks,
      i = e.maxTicksLimit || this._length / this._tickSize(),
      n = e.major.enabled ? getMajorIndices(t) : [],
      o = n.length,
      a = n[0],
      r = n[o - 1],
      s = [];
    if (o > i) return skipMajors(t, s, n, o / i), s;
    const l = calculateSpacing(n, t, i);
    if (o > 0) {
      let e, i;
      const c = o > 1 ? Math.round((r - a) / (o - 1)) : null;
      for (
        skip(t, s, l, isNullOrUndef(c) ? 0 : a - c, a), e = 0, i = o - 1;
        e < i;
        e++
      )
        skip(t, s, l, n[e], n[e + 1]);
      return skip(t, s, l, r, isNullOrUndef(c) ? t.length : r + c), s;
    }
    return skip(t, s, l), s;
  }
  _tickSize() {
    const t = this.options.ticks,
      e = toRadians(this.labelRotation),
      i = Math.abs(Math.cos(e)),
      n = Math.abs(Math.sin(e)),
      o = this._getLabelSizes(),
      a = t.autoSkipPadding || 0,
      r = o ? o.widest.width + a : 0,
      s = o ? o.highest.height + a : 0;
    return this.isHorizontal()
      ? s * i > r * n
        ? r / i
        : s / n
      : s * n < r * i
      ? s / i
      : r / n;
  }
  _isVisible() {
    const t = this.options.display;
    return 'auto' !== t ? !!t : this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(t) {
    const e = this,
      i = e.axis,
      n = e.chart,
      o = e.options,
      { gridLines: a, position: r } = o,
      s = a.offsetGridLines,
      l = e.isHorizontal(),
      c = e.ticks,
      d = c.length + (s ? 1 : 0),
      h = getTickMarkLength(a),
      u = [];
    let g = { chart: n, scale: e, tick: c[0], index: 0 };
    const p = a.drawBorder ? resolve([a.borderWidth, a.lineWidth, 0], g, 0) : 0,
      f = p / 2,
      m = function (t) {
        return _alignPixel(n, t, p);
      };
    let b, x, _, y, v, M, P, S, k, w, A, O;
    if ('top' === r)
      (b = m(e.bottom)),
        (M = e.bottom - h),
        (S = b - f),
        (w = m(t.top) + f),
        (O = t.bottom);
    else if ('bottom' === r)
      (b = m(e.top)),
        (w = t.top),
        (O = m(t.bottom) - f),
        (M = b + f),
        (S = e.top + h);
    else if ('left' === r)
      (b = m(e.right)),
        (v = e.right - h),
        (P = b - f),
        (k = m(t.left) + f),
        (A = t.right);
    else if ('right' === r)
      (b = m(e.left)),
        (k = t.left),
        (A = m(t.right) - f),
        (v = b + f),
        (P = e.left + h);
    else if ('x' === i) {
      if ('center' === r) b = m((t.top + t.bottom) / 2);
      else if (isObject(r)) {
        const t = Object.keys(r)[0],
          i = r[t];
        b = m(e.chart.scales[t].getPixelForValue(i));
      }
      (w = t.top), (O = t.bottom), (S = (M = b + f) + h);
    } else if ('y' === i) {
      if ('center' === r) b = m((t.left + t.right) / 2);
      else if (isObject(r)) {
        const t = Object.keys(r)[0],
          i = r[t];
        b = m(e.chart.scales[t].getPixelForValue(i));
      }
      (P = (v = b - f) - h), (k = t.left), (A = t.right);
    }
    for (x = 0; x < d; ++x) {
      const t = c[x] || {};
      g = { chart: n, scale: e, tick: t, index: x };
      const i = resolve([a.lineWidth], g, x),
        o = resolve([a.color], g, x),
        r = a.borderDash || [],
        d = resolve([a.borderDashOffset], g, x);
      void 0 !== (_ = getPixelForGridLine(e, x, s)) &&
        ((y = _alignPixel(n, _, i)),
        l ? (v = P = k = A = y) : (M = S = w = O = y),
        u.push({
          tx1: v,
          ty1: M,
          tx2: P,
          ty2: S,
          x1: k,
          y1: w,
          x2: A,
          y2: O,
          width: i,
          color: o,
          borderDash: r,
          borderDashOffset: d,
        }));
    }
    return (e._ticksLength = d), (e._borderValue = b), u;
  }
  _computeLabelItems(t) {
    const e = this,
      i = e.axis,
      n = e.options,
      { position: o, ticks: a } = n,
      r = a.mirror,
      s = e.isHorizontal(),
      l = e.ticks,
      c = a.padding,
      d = getTickMarkLength(n.gridLines),
      h = -toRadians(e.labelRotation),
      u = [];
    let g, p, f, m, b, x, _, y, v, M, P, S;
    if ('top' === o) (x = e.bottom - d - c), (_ = h ? 'left' : 'center');
    else if ('bottom' === o) (x = e.top + d + c), (_ = h ? 'right' : 'center');
    else if ('left' === o)
      (b = e.right - (r ? 0 : d) - c), (_ = r ? 'left' : 'right');
    else if ('right' === o)
      (b = e.left + (r ? 0 : d) + c), (_ = r ? 'right' : 'left');
    else if ('x' === i) {
      if ('center' === o) x = (t.top + t.bottom) / 2 + d + c;
      else if (isObject(o)) {
        const t = Object.keys(o)[0],
          i = o[t];
        x = e.chart.scales[t].getPixelForValue(i) + d + c;
      }
      _ = h ? 'right' : 'center';
    } else if ('y' === i) {
      if ('center' === o) b = (t.left + t.right) / 2 - d - c;
      else if (isObject(o)) {
        const t = Object.keys(o)[0],
          i = o[t];
        b = e.chart.scales[t].getPixelForValue(i);
      }
      _ = 'right';
    }
    for (g = 0, p = l.length; g < p; ++g)
      (m = (f = l[g]).label),
        (y = e.getPixelForTick(g) + a.labelOffset),
        (M = (v = e._resolveTickFontOptions(g)).lineHeight),
        (P = isArray(m) ? m.length : 1),
        s
          ? ((b = y),
            'top' === o
              ? ((S = (Math.sin(h) * (P / 2) + 0.5) * M),
                (S -= (0 === h ? P - 0.5 : Math.cos(h) * (P / 2)) * M))
              : ((S = Math.sin(h) * (P / 2) * M),
                (S += (0 === h ? 0.5 : Math.cos(h) * (P / 2)) * M)))
          : ((x = y), (S = ((1 - P) * M) / 2)),
        u.push({
          x: b,
          y: x,
          rotation: h,
          label: m,
          font: v,
          textOffset: S,
          textAlign: _,
        });
    return u;
  }
  drawGrid(t) {
    const e = this,
      i = e.options.gridLines,
      n = e.ctx,
      o = e.chart;
    let a = { chart: o, scale: e, tick: e.ticks[0], index: 0 };
    const r = i.drawBorder ? resolve([i.borderWidth, i.lineWidth, 0], a, 0) : 0,
      s = e._gridLineItems || (e._gridLineItems = e._computeGridLineItems(t));
    let l, c;
    if (i.display)
      for (l = 0, c = s.length; l < c; ++l) {
        const t = s[l],
          e = t.width,
          o = t.color;
        e &&
          o &&
          (n.save(),
          (n.lineWidth = e),
          (n.strokeStyle = o),
          n.setLineDash &&
            (n.setLineDash(t.borderDash),
            (n.lineDashOffset = t.borderDashOffset)),
          n.beginPath(),
          i.drawTicks && (n.moveTo(t.tx1, t.ty1), n.lineTo(t.tx2, t.ty2)),
          i.drawOnChartArea && (n.moveTo(t.x1, t.y1), n.lineTo(t.x2, t.y2)),
          n.stroke(),
          n.restore());
      }
    if (r) {
      const t = r;
      a = {
        chart: o,
        scale: e,
        tick: e.ticks[e._ticksLength - 1],
        index: e._ticksLength - 1,
      };
      const s = resolve([i.lineWidth, 1], a, e._ticksLength - 1),
        l = e._borderValue;
      let c, d, h, u;
      e.isHorizontal()
        ? ((c = _alignPixel(o, e.left, t) - t / 2),
          (d = _alignPixel(o, e.right, s) + s / 2),
          (h = u = l))
        : ((h = _alignPixel(o, e.top, t) - t / 2),
          (u = _alignPixel(o, e.bottom, s) + s / 2),
          (c = d = l)),
        (n.lineWidth = r),
        (n.strokeStyle = resolve([i.borderColor, i.color], a, 0)),
        n.beginPath(),
        n.moveTo(c, h),
        n.lineTo(d, u),
        n.stroke();
    }
  }
  drawLabels(t) {
    const e = this;
    if (!e.options.ticks.display) return;
    const i = e.ctx,
      n = e._labelItems || (e._labelItems = e._computeLabelItems(t));
    let o, a, r, s;
    for (o = 0, r = n.length; o < r; ++o) {
      const t = n[o],
        e = t.font,
        r = e.lineWidth > 0 && '' !== e.strokeStyle;
      i.save(),
        i.translate(t.x, t.y),
        i.rotate(t.rotation),
        (i.font = e.string),
        (i.fillStyle = e.color),
        (i.textBaseline = 'middle'),
        (i.textAlign = t.textAlign),
        r && ((i.strokeStyle = e.strokeStyle), (i.lineWidth = e.lineWidth));
      const l = t.label;
      let c = t.textOffset;
      if (isArray(l))
        for (a = 0, s = l.length; a < s; ++a)
          r && i.strokeText('' + l[a], 0, c),
            i.fillText('' + l[a], 0, c),
            (c += e.lineHeight);
      else r && i.strokeText(l, 0, c), i.fillText(l, 0, c);
      i.restore();
    }
  }
  drawTitle(t) {
    const e = this,
      i = e.ctx,
      n = e.options,
      o = n.scaleLabel;
    if (!o.display) return;
    const a = toFont(o.font),
      r = toPadding(o.padding),
      s = a.lineHeight / 2,
      l = o.align,
      c = n.position,
      d = e.options.reverse;
    let h,
      u,
      g,
      p = 0;
    if (e.isHorizontal()) {
      switch (l) {
        case 'start':
          (u = e.left + (d ? e.width : 0)), (h = d ? 'right' : 'left');
          break;
        case 'end':
          (u = e.left + (d ? 0 : e.width)), (h = d ? 'left' : 'right');
          break;
        default:
          (u = e.left + e.width / 2), (h = 'center');
      }
      g = 'top' === c ? e.top + s + r.top : e.bottom - s - r.bottom;
    } else {
      const t = 'left' === c;
      switch (((u = t ? e.left + s + r.top : e.right - s - r.top), l)) {
        case 'start':
          (g = e.top + (d ? 0 : e.height)), (h = d === t ? 'right' : 'left');
          break;
        case 'end':
          (g = e.top + (d ? e.height : 0)), (h = d === t ? 'left' : 'right');
          break;
        default:
          (g = e.top + e.height / 2), (h = 'center');
      }
      p = t ? -0.5 * Math.PI : 0.5 * Math.PI;
    }
    i.save(),
      i.translate(u, g),
      i.rotate(p),
      (i.textAlign = h),
      (i.textBaseline = 'middle'),
      (i.fillStyle = a.color),
      (i.font = a.string),
      i.fillText(o.labelString, 0, 0),
      i.restore();
  }
  draw(t) {
    this._isVisible() &&
      (this.drawGrid(t), this.drawTitle(), this.drawLabels(t));
  }
  _layers() {
    const t = this,
      e = t.options,
      i = (e.ticks && e.ticks.z) || 0,
      n = (e.gridLines && e.gridLines.z) || 0;
    return t._isVisible() && i !== n && t.draw === t._draw
      ? [
          {
            z: n,
            draw(e) {
              t.drawGrid(e), t.drawTitle();
            },
          },
          {
            z: i,
            draw(e) {
              t.drawLabels(e);
            },
          },
        ]
      : [
          {
            z: i,
            draw(e) {
              t.draw(e);
            },
          },
        ];
  }
  getMatchingVisibleMetas(t) {
    const e = this,
      i = e.chart.getSortedVisibleDatasetMetas(),
      n = e.axis + 'AxisID',
      o = [];
    let a, r;
    for (a = 0, r = i.length; a < r; ++a) {
      const r = i[a];
      r[n] !== e.id || (t && r.type !== t) || o.push(r);
    }
    return o;
  }
  _resolveTickFontOptions(t) {
    const e = this.options.ticks,
      i = this.ticks || [],
      n = { chart: this.chart, scale: this, tick: i[t], index: t };
    return toFont(resolve([e.font], n));
  }
}
Scale.prototype._draw = Scale.prototype.draw;
const defaultConfig = {};
class CategoryScale extends Scale {
  constructor(t) {
    super(t),
      (this._numLabels = 0),
      (this._startValue = void 0),
      (this._valueRange = 0);
  }
  parse(t, e) {
    const i = this.getLabels();
    if (i[e] === t) return e;
    const n = i.indexOf(t),
      o = i.lastIndexOf(t);
    return -1 === n || n !== o ? e : n;
  }
  determineDataLimits() {
    const t = this,
      e = t.getLabels().length - 1;
    (t.min = Math.max(t._userMin || 0, 0)),
      (t.max = Math.min(t._userMax || e, e));
  }
  buildTicks() {
    const t = this,
      e = t.min,
      i = t.max,
      n = t.options.offset;
    let o = t.getLabels();
    return (
      (o = 0 === e && i === o.length - 1 ? o : o.slice(e, i + 1)),
      (t._numLabels = o.length),
      (t._valueRange = Math.max(o.length - (n ? 0 : 1), 1)),
      (t._startValue = t.min - (n ? 0.5 : 0)),
      o.map((t) => ({ value: t }))
    );
  }
  getLabelForValue(t) {
    const e = this.getLabels();
    return t >= 0 && t < e.length ? e[t] : t;
  }
  configure() {
    const t = this;
    super.configure(),
      t.isHorizontal() || (t._reversePixels = !t._reversePixels);
  }
  getPixelForValue(t) {
    const e = this;
    return (
      'number' != typeof t && (t = e.parse(t)),
      e.getPixelForDecimal((t - e._startValue) / e._valueRange)
    );
  }
  getPixelForTick(t) {
    const e = this.ticks;
    return t < 0 || t > e.length - 1
      ? null
      : this.getPixelForValue((t * this._numLabels) / e.length + this.min);
  }
  getValueForPixel(t) {
    const e = Math.round(
      this._startValue + this.getDecimalForPixel(t) * this._valueRange,
    );
    return Math.min(Math.max(e, 0), this.ticks.length - 1);
  }
  getBasePixel() {
    return this.bottom;
  }
}
function niceNum(t) {
  const e = Math.floor(log10(t)),
    i = t / Math.pow(10, e);
  let n;
  return (n = i <= 1 ? 1 : i <= 2 ? 2 : i <= 5 ? 5 : 10) * Math.pow(10, e);
}
function generateTicks(t, e) {
  const i = [],
    { stepSize: n, min: o, max: a, precision: r } = t,
    s = n || 1,
    l = t.maxTicks - 1,
    { min: c, max: d } = e;
  let h,
    u,
    g,
    p,
    f = niceNum((d - c) / l / s) * s;
  if (f < 1e-14 && isNullOrUndef(o) && isNullOrUndef(a))
    return [{ value: c }, { value: d }];
  (p = Math.ceil(d / f) - Math.floor(c / f)) > l &&
    (f = niceNum((p * f) / l / s) * s),
    n || isNullOrUndef(r)
      ? (h = Math.pow(10, _decimalPlaces(f)))
      : ((h = Math.pow(10, r)), (f = Math.ceil(f * h) / h)),
    (u = Math.floor(c / f) * f),
    (g = Math.ceil(d / f) * f),
    !n ||
      isNullOrUndef(o) ||
      isNullOrUndef(a) ||
      (almostWhole((a - o) / n, f / 1e3) && ((u = o), (g = a))),
    (p = almostEquals((p = (g - u) / f), Math.round(p), f / 1e3)
      ? Math.round(p)
      : Math.ceil(p)),
    (u = Math.round(u * h) / h),
    (g = Math.round(g * h) / h),
    i.push({ value: isNullOrUndef(o) ? u : o });
  for (let t = 1; t < p; ++t)
    i.push({ value: Math.round((u + t * f) * h) / h });
  return i.push({ value: isNullOrUndef(a) ? g : a }), i;
}
(CategoryScale.id = 'category'), (CategoryScale.defaults = defaultConfig);
class LinearScaleBase extends Scale {
  constructor(t) {
    super(t),
      (this.start = void 0),
      (this.end = void 0),
      (this._startValue = void 0),
      (this._endValue = void 0),
      (this._valueRange = 0);
  }
  parse(t, e) {
    return isNullOrUndef(t)
      ? NaN
      : ('number' == typeof t || t instanceof Number) && !isFinite(+t)
      ? NaN
      : +t;
  }
  handleTickRangeOptions() {
    const t = this,
      e = t.options;
    if (e.beginAtZero) {
      const e = sign(t.min),
        i = sign(t.max);
      e < 0 && i < 0 ? (t.max = 0) : e > 0 && i > 0 && (t.min = 0);
    }
    const i = void 0 !== e.min || void 0 !== e.suggestedMin,
      n = void 0 !== e.max || void 0 !== e.suggestedMax;
    void 0 !== e.min
      ? (t.min = e.min)
      : void 0 !== e.suggestedMin &&
        (null === t.min
          ? (t.min = e.suggestedMin)
          : (t.min = Math.min(t.min, e.suggestedMin))),
      void 0 !== e.max
        ? (t.max = e.max)
        : void 0 !== e.suggestedMax &&
          (null === t.max
            ? (t.max = e.suggestedMax)
            : (t.max = Math.max(t.max, e.suggestedMax))),
      i !== n &&
        t.min >= t.max &&
        (i ? (t.max = t.min + 1) : (t.min = t.max - 1)),
      t.min === t.max && (t.max++, e.beginAtZero || t.min--);
  }
  getTickLimit() {
    const t = this,
      e = t.options.ticks;
    let i,
      { maxTicksLimit: n, stepSize: o } = e;
    return (
      o
        ? (i = Math.ceil(t.max / o) - Math.floor(t.min / o) + 1)
        : ((i = t.computeTickLimit()), (n = n || 11)),
      n && (i = Math.min(n, i)),
      i
    );
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  handleDirectionalChanges(t) {
    return t;
  }
  buildTicks() {
    const t = this,
      e = t.options,
      i = e.ticks;
    let n = t.getTickLimit();
    let o = generateTicks(
      {
        maxTicks: (n = Math.max(2, n)),
        min: e.min,
        max: e.max,
        precision: i.precision,
        stepSize: valueOrDefault(i.fixedStepSize, i.stepSize),
      },
      t,
    );
    return (
      _setMinAndMaxByKey((o = t.handleDirectionalChanges(o)), t, 'value'),
      e.reverse
        ? (o.reverse(), (t.start = t.max), (t.end = t.min))
        : ((t.start = t.min), (t.end = t.max)),
      o
    );
  }
  configure() {
    const t = this,
      e = t.ticks;
    let i = t.min,
      n = t.max;
    if ((super.configure(), t.options.offset && e.length)) {
      const t = (n - i) / Math.max(e.length - 1, 1) / 2;
      (i -= t), (n += t);
    }
    (t._startValue = i), (t._endValue = n), (t._valueRange = n - i);
  }
  getLabelForValue(t) {
    return new Intl.NumberFormat(this.options.locale).format(t);
  }
}
const defaultConfig$1 = { ticks: { callback: Ticks.formatters.numeric } };
class LinearScale extends LinearScaleBase {
  determineDataLimits() {
    const t = this,
      e = t.options,
      { min: i, max: n } = t.getMinMax(!0);
    (t.min = isNumberFinite(i) ? i : valueOrDefault(e.suggestedMin, 0)),
      (t.max = isNumberFinite(n) ? n : valueOrDefault(e.suggestedMax, 1)),
      e.stacked && i > 0 && (t.min = 0),
      t.handleTickRangeOptions();
  }
  computeTickLimit() {
    const t = this;
    if (t.isHorizontal()) return Math.ceil(t.width / 40);
    const e = t._resolveTickFontOptions(0);
    return Math.ceil(t.height / e.lineHeight);
  }
  handleDirectionalChanges(t) {
    return this.isHorizontal() ? t : t.reverse();
  }
  getPixelForValue(t) {
    return this.getPixelForDecimal((t - this._startValue) / this._valueRange);
  }
  getValueForPixel(t) {
    return this._startValue + this.getDecimalForPixel(t) * this._valueRange;
  }
}
function isMajor(t) {
  return 1 === t / Math.pow(10, Math.floor(log10(t)));
}
function finiteOrDefault(t, e) {
  return isNumberFinite(t) ? t : e;
}
function generateTicks$1(t, e) {
  const i = Math.floor(log10(e.max)),
    n = Math.ceil(e.max / Math.pow(10, i)),
    o = [];
  let a = finiteOrDefault(t.min, Math.pow(10, Math.floor(log10(e.min)))),
    r = Math.floor(log10(a)),
    s = Math.floor(a / Math.pow(10, r)),
    l = r < 0 ? Math.pow(10, Math.abs(r)) : 1;
  do {
    o.push({ value: a, major: isMajor(a) }),
      10 === ++s && ((s = 1), (l = ++r >= 0 ? 1 : l)),
      (a = Math.round(s * Math.pow(10, r) * l) / l);
  } while (r < i || (r === i && s < n));
  const c = finiteOrDefault(t.max, a);
  return o.push({ value: c, major: isMajor(a) }), o;
}
(LinearScale.id = 'linear'), (LinearScale.defaults = defaultConfig$1);
const defaultConfig$2 = {
  ticks: { callback: Ticks.formatters.logarithmic, major: { enabled: !0 } },
};
class LogarithmicScale extends Scale {
  constructor(t) {
    super(t),
      (this.start = void 0),
      (this.end = void 0),
      (this._startValue = void 0),
      (this._valueRange = 0);
  }
  parse(t, e) {
    const i = LinearScaleBase.prototype.parse.apply(this, [t, e]);
    if (0 !== i) return isNumberFinite(i) && i > 0 ? i : NaN;
  }
  determineDataLimits() {
    const { min: t, max: e } = this.getMinMax(!0);
    (this.min = isNumberFinite(t) ? Math.max(0, t) : null),
      (this.max = isNumberFinite(e) ? Math.max(0, e) : null),
      this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    let t = this.min,
      e = this.max;
    t === e &&
      (t <= 0
        ? ((t = 1), (e = 10))
        : ((t = Math.pow(10, Math.floor(log10(t)) - 1)),
          (e = Math.pow(10, Math.floor(log10(e)) + 1)))),
      t <= 0 && (t = Math.pow(10, Math.floor(log10(e)) - 1)),
      e <= 0 && (e = Math.pow(10, Math.floor(log10(t)) + 1)),
      (this.min = t),
      (this.max = e);
  }
  buildTicks() {
    const t = this,
      e = t.options,
      i = generateTicks$1({ min: t._userMin, max: t._userMax }, t);
    let n = !t.isHorizontal();
    return (
      _setMinAndMaxByKey(i, t, 'value'),
      e.reverse
        ? ((n = !n), (t.start = t.max), (t.end = t.min))
        : ((t.start = t.min), (t.end = t.max)),
      n && i.reverse(),
      i
    );
  }
  getLabelForValue(t) {
    return void 0 === t
      ? '0'
      : new Intl.NumberFormat(this.options.locale).format(t);
  }
  configure() {
    const t = this.min;
    super.configure(),
      (this._startValue = log10(t)),
      (this._valueRange = log10(this.max) - log10(t));
  }
  getPixelForValue(t) {
    const e = this;
    return (
      (void 0 !== t && 0 !== t) || (t = e.min),
      e.getPixelForDecimal(
        t === e.min ? 0 : (log10(t) - e._startValue) / e._valueRange,
      )
    );
  }
  getValueForPixel(t) {
    const e = this.getDecimalForPixel(t);
    return Math.pow(10, this._startValue + e * this._valueRange);
  }
}
(LogarithmicScale.id = 'logarithmic'),
  (LogarithmicScale.defaults = defaultConfig$2);
const defaultConfig$3 = {
  display: !0,
  animate: !0,
  position: 'chartArea',
  angleLines: {
    display: !0,
    color: 'rgba(0,0,0,0.1)',
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0,
  },
  gridLines: { circular: !1 },
  ticks: {
    showLabelBackdrop: !0,
    backdropColor: 'rgba(255,255,255,0.75)',
    backdropPaddingY: 2,
    backdropPaddingX: 2,
    callback: Ticks.formatters.numeric,
  },
  pointLabels: { display: !0, font: { size: 10 }, callback: (t) => t },
};
function getTickBackdropHeight(t) {
  const e = t.ticks;
  return e.display && t.display
    ? valueOrDefault(e.font && e.font.size, defaults.font.size) +
        2 * e.backdropPaddingY
    : 0;
}
function measureLabelSize(t, e, i) {
  return isArray(i)
    ? { w: _longestText(t, t.font, i), h: i.length * e }
    : { w: t.measureText(i).width, h: e };
}
function determineLimits(t, e, i, n, o) {
  return t === n || t === o
    ? { start: e - i / 2, end: e + i / 2 }
    : t < n || t > o
    ? { start: e - i, end: e }
    : { start: e, end: e + i };
}
function fitWithPointLabels(t) {
  const e = { l: 0, r: t.width, t: 0, b: t.height - t.paddingTop },
    i = {};
  let n, o, a;
  t._pointLabelSizes = [];
  const r = t.chart.data.labels.length;
  for (n = 0; n < r; n++) {
    a = t.getPointPosition(n, t.drawingArea + 5);
    const r = { chart: t.chart, scale: t, index: n, label: t.pointLabels[n] },
      s = toFont(resolve([t.options.pointLabels.font], r, n));
    (t.ctx.font = s.string),
      (o = measureLabelSize(t.ctx, s.lineHeight, t.pointLabels[n])),
      (t._pointLabelSizes[n] = o);
    const l = t.getIndexAngle(n),
      c = toDegrees(l),
      d = determineLimits(c, a.x, o.w, 0, 180),
      h = determineLimits(c, a.y, o.h, 90, 270);
    d.start < e.l && ((e.l = d.start), (i.l = l)),
      d.end > e.r && ((e.r = d.end), (i.r = l)),
      h.start < e.t && ((e.t = h.start), (i.t = l)),
      h.end > e.b && ((e.b = h.end), (i.b = l));
  }
  t._setReductions(t.drawingArea, e, i);
}
function getTextAlignForAngle(t) {
  return 0 === t || 180 === t ? 'center' : t < 180 ? 'left' : 'right';
}
function fillText(t, e, i, n) {
  let o,
    a,
    r = i.y + n / 2;
  if (isArray(e))
    for (o = 0, a = e.length; o < a; ++o) t.fillText(e[o], i.x, r), (r += n);
  else t.fillText(e, i.x, r);
}
function adjustPointPositionForLabelHeight(t, e, i) {
  90 === t || 270 === t
    ? (i.y -= e.h / 2)
    : (t > 270 || t < 90) && (i.y -= e.h);
}
function drawPointLabels(t) {
  const e = t.ctx,
    i = t.options,
    n = i.pointLabels,
    o = getTickBackdropHeight(i),
    a = t.getDistanceFromCenterForValue(i.ticks.reverse ? t.min : t.max);
  e.save(), (e.textBaseline = 'middle');
  for (let i = t.chart.data.labels.length - 1; i >= 0; i--) {
    const r = 0 === i ? o / 2 : 0,
      s = t.getPointPosition(i, a + r + 5),
      l = { chart: t.chart, scale: t, index: i, label: t.pointLabels[i] },
      c = toFont(resolve([n.font], l, i));
    (e.font = c.string), (e.fillStyle = c.color);
    const d = toDegrees(t.getIndexAngle(i));
    (e.textAlign = getTextAlignForAngle(d)),
      adjustPointPositionForLabelHeight(d, t._pointLabelSizes[i], s),
      fillText(e, t.pointLabels[i], s, c.lineHeight);
  }
  e.restore();
}
function drawRadiusLine(t, e, i, n) {
  const o = t.ctx,
    a = e.circular,
    r = t.chart.data.labels.length,
    s = { chart: t.chart, scale: t, index: n, tick: t.ticks[n] },
    l = resolve([e.color], s, n - 1),
    c = resolve([e.lineWidth], s, n - 1);
  let d;
  if ((a || r) && l && c) {
    if (
      (o.save(),
      (o.strokeStyle = l),
      (o.lineWidth = c),
      o.setLineDash &&
        (o.setLineDash(resolve([e.borderDash, []], s)),
        (o.lineDashOffset = resolve([e.borderDashOffset], s, n - 1))),
      o.beginPath(),
      a)
    )
      o.arc(t.xCenter, t.yCenter, i, 0, 2 * Math.PI);
    else {
      (d = t.getPointPosition(0, i)), o.moveTo(d.x, d.y);
      for (let e = 1; e < r; e++)
        (d = t.getPointPosition(e, i)), o.lineTo(d.x, d.y);
    }
    o.closePath(), o.stroke(), o.restore();
  }
}
function numberOrZero(t) {
  return isNumber(t) ? t : 0;
}
class RadialLinearScale extends LinearScaleBase {
  constructor(t) {
    super(t),
      (this.xCenter = void 0),
      (this.yCenter = void 0),
      (this.drawingArea = void 0),
      (this.pointLabels = []);
  }
  init(t) {
    super.init(t), (this.axis = 'r');
  }
  setDimensions() {
    const t = this;
    (t.width = t.maxWidth),
      (t.height = t.maxHeight),
      (t.paddingTop = getTickBackdropHeight(t.options) / 2),
      (t.xCenter = Math.floor(t.width / 2)),
      (t.yCenter = Math.floor((t.height - t.paddingTop) / 2)),
      (t.drawingArea = Math.min(t.height - t.paddingTop, t.width) / 2);
  }
  determineDataLimits() {
    const { min: t, max: e } = this.getMinMax(!1);
    (this.min = isNumberFinite(t) && !isNaN(t) ? t : 0),
      (this.max = isNumberFinite(e) && !isNaN(e) ? e : 0),
      this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(t) {
    const e = this;
    LinearScaleBase.prototype.generateTickLabels.call(e, t),
      (e.pointLabels = e.chart.data.labels.map((t, i) => {
        const n = callback(e.options.pointLabels.callback, [t, i], e);
        return n || 0 === n ? n : '';
      }));
  }
  fit() {
    const t = this,
      e = t.options;
    e.display && e.pointLabels.display
      ? fitWithPointLabels(t)
      : t.setCenterPoint(0, 0, 0, 0);
  }
  _setReductions(t, e, i) {
    const n = this;
    let o = e.l / Math.sin(i.l),
      a = Math.max(e.r - n.width, 0) / Math.sin(i.r),
      r = -e.t / Math.cos(i.t),
      s = -Math.max(e.b - (n.height - n.paddingTop), 0) / Math.cos(i.b);
    (o = numberOrZero(o)),
      (a = numberOrZero(a)),
      (r = numberOrZero(r)),
      (s = numberOrZero(s)),
      (n.drawingArea = Math.min(
        Math.floor(t - (o + a) / 2),
        Math.floor(t - (r + s) / 2),
      )),
      n.setCenterPoint(o, a, r, s);
  }
  setCenterPoint(t, e, i, n) {
    const o = this,
      a = o.width - e - o.drawingArea,
      r = t + o.drawingArea,
      s = i + o.drawingArea,
      l = o.height - o.paddingTop - n - o.drawingArea;
    (o.xCenter = Math.floor((r + a) / 2 + o.left)),
      (o.yCenter = Math.floor((s + l) / 2 + o.top + o.paddingTop));
  }
  getIndexAngle(t) {
    const e = this.chart;
    return _normalizeAngle(
      t * ((2 * Math.PI) / e.data.labels.length) +
        toRadians((e.options || {}).startAngle || 0),
    );
  }
  getDistanceFromCenterForValue(t) {
    const e = this;
    if (isNullOrUndef(t)) return NaN;
    const i = e.drawingArea / (e.max - e.min);
    return e.options.reverse ? (e.max - t) * i : (t - e.min) * i;
  }
  getValueForDistanceFromCenter(t) {
    if (isNullOrUndef(t)) return NaN;
    const e = this,
      i = t / (e.drawingArea / (e.max - e.min));
    return e.options.reverse ? e.max - i : e.min + i;
  }
  getPointPosition(t, e) {
    const i = this.getIndexAngle(t) - Math.PI / 2;
    return {
      x: Math.cos(i) * e + this.xCenter,
      y: Math.sin(i) * e + this.yCenter,
      angle: i,
    };
  }
  getPointPositionForValue(t, e) {
    return this.getPointPosition(t, this.getDistanceFromCenterForValue(e));
  }
  getBasePosition(t) {
    return this.getPointPositionForValue(t || 0, this.getBaseValue());
  }
  drawGrid() {
    const t = this,
      e = t.ctx,
      i = t.options,
      n = i.gridLines,
      o = i.angleLines;
    let a, r, s;
    if (
      (i.pointLabels.display && drawPointLabels(t),
      n.display &&
        t.ticks.forEach((e, i) => {
          0 !== i &&
            ((r = t.getDistanceFromCenterForValue(t.ticks[i].value)),
            drawRadiusLine(t, n, r, i));
        }),
      o.display)
    ) {
      for (e.save(), a = t.chart.data.labels.length - 1; a >= 0; a--) {
        const l = {
            chart: t.chart,
            scale: t,
            index: a,
            label: t.pointLabels[a],
          },
          c = resolve([o.lineWidth, n.lineWidth], l, a),
          d = resolve([o.color, n.color], l, a);
        c &&
          d &&
          ((e.lineWidth = c),
          (e.strokeStyle = d),
          e.setLineDash &&
            (e.setLineDash(resolve([o.borderDash, n.borderDash, []], l)),
            (e.lineDashOffset = resolve(
              [o.borderDashOffset, n.borderDashOffset, 0],
              l,
              a,
            ))),
          (r = t.getDistanceFromCenterForValue(
            i.ticks.reverse ? t.min : t.max,
          )),
          (s = t.getPointPosition(a, r)),
          e.beginPath(),
          e.moveTo(t.xCenter, t.yCenter),
          e.lineTo(s.x, s.y),
          e.stroke());
      }
      e.restore();
    }
  }
  drawLabels() {
    const t = this,
      e = t.ctx,
      i = t.options,
      n = i.ticks;
    if (!n.display) return;
    const o = t.getIndexAngle(0);
    let a, r;
    e.save(),
      e.translate(t.xCenter, t.yCenter),
      e.rotate(o),
      (e.textAlign = 'center'),
      (e.textBaseline = 'middle'),
      t.ticks.forEach((o, s) => {
        const l = { chart: t.chart, scale: t, index: s, tick: o };
        if (0 === s && !i.reverse) return;
        const c = t._resolveTickFontOptions(s);
        (e.font = c.string),
          (a = t.getDistanceFromCenterForValue(t.ticks[s].value)),
          resolve([n.showLabelBackdrop], l, s) &&
            ((r = e.measureText(o.label).width),
            (e.fillStyle = resolve([n.backdropColor], l, s)),
            e.fillRect(
              -r / 2 - n.backdropPaddingX,
              -a - c.size / 2 - n.backdropPaddingY,
              r + 2 * n.backdropPaddingX,
              c.size + 2 * n.backdropPaddingY,
            )),
          (e.fillStyle = c.color),
          e.fillText(o.label, 0, -a);
      }),
      e.restore();
  }
  drawTitle() {}
}
(RadialLinearScale.id = 'radialLinear'),
  (RadialLinearScale.defaults = defaultConfig$3);
const MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991,
  INTERVALS = {
    millisecond: { common: !0, size: 1, steps: 1e3 },
    second: { common: !0, size: 1e3, steps: 60 },
    minute: { common: !0, size: 6e4, steps: 60 },
    hour: { common: !0, size: 36e5, steps: 24 },
    day: { common: !0, size: 864e5, steps: 30 },
    week: { common: !1, size: 6048e5, steps: 4 },
    month: { common: !0, size: 2628e6, steps: 12 },
    quarter: { common: !1, size: 7884e6, steps: 4 },
    year: { common: !0, size: 3154e7 },
  },
  UNITS = Object.keys(INTERVALS);
function sorter(t, e) {
  return t - e;
}
function arrayUnique(t) {
  const e = new Set();
  let i, n;
  for (i = 0, n = t.length; i < n; ++i) e.add(t[i]);
  if (e.size === n) return t;
  const o = [];
  return (
    e.forEach((t) => {
      o.push(t);
    }),
    o
  );
}
function parse(t, e) {
  if (isNullOrUndef(e)) return null;
  const i = t._adapter,
    n = t.options.time,
    { parser: o, round: a, isoWeekday: r } = n;
  let s = e;
  return (
    'function' == typeof o && (s = o(s)),
    isNumberFinite(s) ||
      (s = 'string' == typeof o ? i.parse(s, o) : i.parse(s)),
    null === s
      ? s
      : (a &&
          (s =
            'week' === a && r
              ? t._adapter.startOf(s, 'isoWeek', r)
              : t._adapter.startOf(s, a)),
        +s)
  );
}
function getDataTimestamps(t) {
  const e = 'series' === t.options.distribution;
  let i,
    n,
    o = t._cache.data || [];
  if (o.length) return o;
  const a = t.getMatchingVisibleMetas();
  if (e && a.length) return a[0].controller.getAllParsedValues(t);
  for (i = 0, n = a.length; i < n; ++i)
    o = o.concat(a[i].controller.getAllParsedValues(t));
  return (t._cache.data = arrayUnique(o.sort(sorter)));
}
function getLabelTimestamps(t) {
  const e = 'series' === t.options.distribution,
    i = t._cache.labels || [];
  let n, o;
  if (i.length) return i;
  const a = t.getLabels();
  for (n = 0, o = a.length; n < o; ++n) i.push(parse(t, a[n]));
  return (t._cache.labels = e ? i : arrayUnique(i.sort(sorter)));
}
function getAllTimestamps(t) {
  let e = t._cache.all || [];
  if (e.length) return e;
  const i = getDataTimestamps(t),
    n = getLabelTimestamps(t);
  return (
    (e =
      i.length && n.length
        ? arrayUnique(i.concat(n).sort(sorter))
        : i.length
        ? i
        : n),
    (e = t._cache.all = e)
  );
}
function buildLookupTable(t, e, i, n) {
  if ('linear' === n || !t.length)
    return [
      { time: e, pos: 0 },
      { time: i, pos: 1 },
    ];
  const o = [],
    a = [e];
  let r, s, l, c, d;
  for (r = 0, s = t.length; r < s; ++r) (c = t[r]) > e && c < i && a.push(c);
  for (a.push(i), r = 0, s = a.length; r < s; ++r)
    (d = a[r + 1]),
      (l = a[r - 1]),
      (c = a[r]),
      (void 0 !== l && void 0 !== d && Math.round((d + l) / 2) === c) ||
        o.push({ time: c, pos: r / (s - 1) });
  return o;
}
function interpolate(t, e, i, n) {
  const { lo: o, hi: a } = _lookupByKey(t, e, i),
    r = t[o],
    s = t[a],
    l = s[e] - r[e],
    c = l ? (i - r[e]) / l : 0,
    d = (s[n] - r[n]) * c;
  return r[n] + d;
}
function determineUnitForAutoTicks(t, e, i, n) {
  const o = UNITS.length;
  for (let a = UNITS.indexOf(t); a < o - 1; ++a) {
    const t = INTERVALS[UNITS[a]],
      o = t.steps ? t.steps : MAX_INTEGER;
    if (t.common && Math.ceil((i - e) / (o * t.size)) <= n) return UNITS[a];
  }
  return UNITS[o - 1];
}
function determineUnitForFormatting(t, e, i, n, o) {
  for (let a = UNITS.length - 1; a >= UNITS.indexOf(i); a--) {
    const i = UNITS[a];
    if (INTERVALS[i].common && t._adapter.diff(o, n, i) >= e - 1) return i;
  }
  return UNITS[i ? UNITS.indexOf(i) : 0];
}
function determineMajorUnit(t) {
  for (let e = UNITS.indexOf(t) + 1, i = UNITS.length; e < i; ++e)
    if (INTERVALS[UNITS[e]].common) return UNITS[e];
}
function addTick(t, e, i) {
  if (!t.length) return;
  const { lo: n, hi: o } = _lookup(t, i);
  e[t[n] >= i ? t[n] : t[o]] = !0;
}
function generate(t) {
  const e = t._adapter,
    i = t.min,
    n = t.max,
    o = t.options,
    a = o.time,
    r =
      a.unit ||
      determineUnitForAutoTicks(a.minUnit, i, n, t._getLabelCapacity(i)),
    s = valueOrDefault(a.stepSize, 1),
    l = 'week' === r && a.isoWeekday,
    c = {};
  let d,
    h = i;
  if (
    (l && (h = +e.startOf(h, 'isoWeek', l)),
    (h = +e.startOf(h, l ? 'day' : r)),
    e.diff(n, i, r) > 1e5 * s)
  )
    throw new Error(
      i + ' and ' + n + ' are too far apart with stepSize of ' + s + ' ' + r,
    );
  if ('data' === t.options.ticks.source) {
    const i = getDataTimestamps(t);
    for (d = h; d < n; d = +e.add(d, s, r)) addTick(i, c, d);
    (d !== n && 'ticks' !== o.bounds) || addTick(i, c, d);
  } else {
    for (d = h; d < n; d = +e.add(d, s, r)) c[d] = !0;
    (d !== n && 'ticks' !== o.bounds) || (c[d] = !0);
  }
  return Object.keys(c).map((t) => +t);
}
function computeOffsets(t, e, i, n, o) {
  let a,
    r,
    s = 0,
    l = 0;
  return (
    o.offset &&
      e.length &&
      ((a = interpolate(t, 'time', e[0], 'pos')),
      (s =
        1 === e.length ? 1 - a : (interpolate(t, 'time', e[1], 'pos') - a) / 2),
      (r = interpolate(t, 'time', e[e.length - 1], 'pos')),
      (l =
        1 === e.length
          ? r
          : (r - interpolate(t, 'time', e[e.length - 2], 'pos')) / 2)),
    { start: s, end: l, factor: 1 / (s + 1 + l) }
  );
}
function setMajorTicks(t, e, i, n) {
  const o = t._adapter,
    a = +o.startOf(e[0].value, n),
    r = e[e.length - 1].value;
  let s, l;
  for (s = a; s <= r; s = +o.add(s, 1, n)) (l = i[s]) >= 0 && (e[l].major = !0);
  return e;
}
function ticksFromTimestamps(t, e, i) {
  const n = [],
    o = {},
    a = e.length;
  let r, s;
  for (r = 0; r < a; ++r) (o[(s = e[r])] = r), n.push({ value: s, major: !1 });
  return 0 !== a && i ? setMajorTicks(t, n, o, i) : n;
}
function getTimestampsForTicks(t) {
  return 'labels' === t.options.ticks.source
    ? getLabelTimestamps(t)
    : generate(t);
}
function getTimestampsForTable(t) {
  return 'series' === t.options.distribution
    ? getAllTimestamps(t)
    : [t.min, t.max];
}
function getLabelBounds(t) {
  const e = getLabelTimestamps(t);
  let i = Number.POSITIVE_INFINITY,
    n = Number.NEGATIVE_INFINITY;
  return e.length && ((i = e[0]), (n = e[e.length - 1])), { min: i, max: n };
}
const defaultConfig$4 = {
  distribution: 'linear',
  bounds: 'data',
  adapters: {},
  time: {
    parser: !1,
    unit: !1,
    round: !1,
    isoWeekday: !1,
    minUnit: 'millisecond',
    displayFormats: {},
  },
  ticks: { autoSkip: !1, source: 'auto', major: { enabled: !1 } },
};
class TimeScale extends Scale {
  constructor(t) {
    super(t),
      (this._cache = { data: [], labels: [], all: [] }),
      (this._unit = 'day'),
      (this._majorUnit = void 0),
      (this._offsets = {}),
      (this._table = []);
  }
  init(t) {
    const e = t.time || (t.time = {}),
      i = (this._adapter = new _adapters._date(t.adapters.date));
    mergeIf(e.displayFormats, i.formats()), super.init(t);
  }
  parse(t, e) {
    return void 0 === t ? NaN : parse(this, t);
  }
  parseObject(t, e, i) {
    return t && t.t
      ? this.parse(t.t, i)
      : void 0 !== t[e]
      ? this.parse(t[e], i)
      : null;
  }
  invalidateCaches() {
    this._cache = { data: [], labels: [], all: [] };
  }
  determineDataLimits() {
    const t = this,
      e = t.options,
      i = t._adapter,
      n = e.time.unit || 'day';
    let { min: o, max: a, minDefined: r, maxDefined: s } = t.getUserBounds();
    function l(t) {
      r || isNaN(t.min) || (o = Math.min(o, t.min)),
        s || isNaN(t.max) || (a = Math.max(a, t.max));
    }
    (r && s) ||
      (l(getLabelBounds(t)),
      ('ticks' === e.bounds && 'labels' === e.ticks.source) ||
        l(t.getMinMax(!1))),
      (o = isNumberFinite(o) && !isNaN(o) ? o : +i.startOf(Date.now(), n)),
      (a = isNumberFinite(a) && !isNaN(a) ? a : +i.endOf(Date.now(), n) + 1),
      (t.min = Math.min(o, a)),
      (t.max = Math.max(o + 1, a));
  }
  buildTicks() {
    const t = this,
      e = t.options,
      i = e.time,
      n = e.ticks,
      o = e.distribution,
      a = getTimestampsForTicks(t);
    'ticks' === e.bounds &&
      a.length &&
      ((t.min = t._userMin || a[0]), (t.max = t._userMax || a[a.length - 1]));
    const r = t.min,
      s = t.max,
      l = _filterBetween(a, r, s);
    return (
      (t._unit =
        i.unit ||
        (n.autoSkip
          ? determineUnitForAutoTicks(
              i.minUnit,
              t.min,
              t.max,
              t._getLabelCapacity(r),
            )
          : determineUnitForFormatting(t, l.length, i.minUnit, t.min, t.max))),
      (t._majorUnit =
        n.major.enabled && 'year' !== t._unit
          ? determineMajorUnit(t._unit)
          : void 0),
      (t._table = buildLookupTable(getTimestampsForTable(t), r, s, o)),
      (t._offsets = computeOffsets(t._table, a, r, s, e)),
      e.reverse && l.reverse(),
      ticksFromTimestamps(t, l, t._majorUnit)
    );
  }
  getLabelForValue(t) {
    const e = this._adapter,
      i = this.options.time;
    return i.tooltipFormat
      ? e.format(t, i.tooltipFormat)
      : e.format(t, i.displayFormats.datetime);
  }
  _tickFormatFunction(t, e, i, n) {
    const o = this.options,
      a = o.time.displayFormats,
      r = this._unit,
      s = this._majorUnit,
      l = r && a[r],
      c = s && a[s],
      d = i[e],
      h = s && c && d && d.major,
      u = this._adapter.format(t, n || (h ? c : l)),
      g = o.ticks.callback;
    return g ? g(u, e, i) : u;
  }
  generateTickLabels(t) {
    let e, i, n;
    for (e = 0, i = t.length; e < i; ++e)
      (n = t[e]).label = this._tickFormatFunction(n.value, e, t);
  }
  getPixelForValue(t) {
    const e = this._offsets,
      i = interpolate(this._table, 'time', t, 'pos');
    return this.getPixelForDecimal((e.start + i) * e.factor);
  }
  getValueForPixel(t) {
    const e = this._offsets,
      i = this.getDecimalForPixel(t) / e.factor - e.end;
    return interpolate(this._table, 'pos', i, 'time');
  }
  _getLabelSize(t) {
    const e = this.options.ticks,
      i = this.ctx.measureText(t).width,
      n = toRadians(this.isHorizontal() ? e.maxRotation : e.minRotation),
      o = Math.cos(n),
      a = Math.sin(n),
      r = this._resolveTickFontOptions(0).size;
    return { w: i * o + r * a, h: i * a + r * o };
  }
  _getLabelCapacity(t) {
    const e = this,
      i = e.options.time,
      n = i.displayFormats,
      o = n[i.unit] || n.millisecond,
      a = e._tickFormatFunction(
        t,
        0,
        ticksFromTimestamps(e, [t], e._majorUnit),
        o,
      ),
      r = e._getLabelSize(a),
      s = Math.floor(e.isHorizontal() ? e.width / r.w : e.height / r.h) - 1;
    return s > 0 ? s : 1;
  }
}
(TimeScale.id = 'time'), (TimeScale.defaults = defaultConfig$4);
var scales = Object.freeze({
  __proto__: null,
  CategoryScale: CategoryScale,
  LinearScale: LinearScale,
  LogarithmicScale: LogarithmicScale,
  RadialLinearScale: RadialLinearScale,
  TimeScale: TimeScale,
});
function getLineByIndex(t, e) {
  const i = t.getDatasetMeta(e);
  return i && t.isDatasetVisible(e) ? i.dataset : null;
}
function parseFillOption(t) {
  const e = t.options,
    i = e.fill;
  let n = valueOrDefault(i && i.target, i);
  return (
    void 0 === n && (n = !!e.backgroundColor),
    !1 !== n && null !== n && (!0 === n ? 'origin' : n)
  );
}
function decodeFill(t, e, i) {
  const n = parseFillOption(t);
  let o = parseFloat(n);
  return isNumberFinite(o) && Math.floor(o) === o
    ? (('-' !== n[0] && '+' !== n[0]) || (o = e + o),
      !(o === e || o < 0 || o >= i) && o)
    : ['origin', 'start', 'end'].indexOf(n) >= 0 && n;
}
function computeLinearBoundary(t) {
  const { scale: e = {}, fill: i } = t;
  let n,
    o = null;
  return (
    'start' === i
      ? (o = e.bottom)
      : 'end' === i
      ? (o = e.top)
      : e.getBasePixel && (o = e.getBasePixel()),
    isNumberFinite(o)
      ? { x: (n = e.isHorizontal()) ? o : null, y: n ? null : o }
      : null
  );
}
defaults.set('plugins', { filler: { propagate: !0 } });
class simpleArc {
  constructor(t) {
    (this.x = t.x), (this.y = t.y), (this.radius = t.radius);
  }
  pathSegment(t, e, i) {
    const { x: n, y: o, radius: a } = this;
    return (
      (e = e || { start: 0, end: 2 * Math.PI }),
      i.reverse
        ? t.arc(n, o, a, e.end, e.start, !0)
        : t.arc(n, o, a, e.start, e.end),
      !i.bounds
    );
  }
  interpolate(t, e) {
    const { x: i, y: n, radius: o } = this,
      a = t.angle;
    if ('angle' === e)
      return { x: i + Math.cos(a) * o, y: n + Math.sin(a) * o, angle: a };
  }
}
function computeCircularBoundary(t) {
  const { scale: e, fill: i } = t,
    n = e.options,
    o = e.getLabels().length,
    a = [],
    r = n.reverse ? e.max : e.min,
    s = n.reverse ? e.min : e.max,
    l = 'start' === i ? r : 'end' === i ? s : e.getBaseValue();
  let c, d;
  if (n.gridLines.circular)
    return (
      (d = e.getPointPositionForValue(0, r)),
      new simpleArc({
        x: d.x,
        y: d.y,
        radius: e.getDistanceFromCenterForValue(l),
      })
    );
  for (c = 0; c < o; ++c) a.push(e.getPointPositionForValue(c, l));
  return a;
}
function computeBoundary(t) {
  return (t.scale || {}).getPointPositionForValue
    ? computeCircularBoundary(t)
    : computeLinearBoundary(t);
}
function pointsFromSegments(t, e) {
  const { x: i = null, y: n = null } = t || {},
    o = e.points,
    a = [];
  return (
    e.segments.forEach((t) => {
      const e = o[t.start],
        r = o[t.end];
      null !== n
        ? (a.push({ x: e.x, y: n, _prop: 'x', _ref: e }),
          a.push({ x: r.x, y: n, _prop: 'x', _ref: r }))
        : null !== i &&
          (a.push({ x: i, y: e.y, _prop: 'y', _ref: e }),
          a.push({ x: i, y: r.y, _prop: 'y', _ref: r }));
    }),
    a
  );
}
function getTarget(t) {
  const { chart: e, fill: i, line: n } = t;
  if (isNumberFinite(i)) return getLineByIndex(e, i);
  const o = computeBoundary(t);
  let a = [],
    r = !1,
    s = !1;
  return o instanceof simpleArc
    ? o
    : (isArray(o)
        ? ((r = !0), (a = o))
        : ((a = pointsFromSegments(o, n)), (s = !0)),
      a.length
        ? new Line({
            points: a,
            options: { tension: 0 },
            _loop: r,
            _fullLoop: r,
            _refPoints: s,
          })
        : null);
}
function resolveTarget(t, e, i) {
  let n = t[e].fill;
  const o = [e];
  let a;
  if (!i) return n;
  for (; !1 !== n && -1 === o.indexOf(n); ) {
    if (!isNumberFinite(n)) return n;
    if (!(a = t[n])) return !1;
    if (a.visible) return n;
    o.push(n), (n = a.fill);
  }
  return !1;
}
function _clip(t, e, i) {
  t.beginPath(),
    e.path(t),
    t.lineTo(e.last().x, i),
    t.lineTo(e.first().x, i),
    t.closePath(),
    t.clip();
}
function getBounds(t, e, i, n) {
  if (n) return;
  let o = e[t],
    a = i[t];
  return (
    'angle' === t && ((o = _normalizeAngle(o)), (a = _normalizeAngle(a))),
    { property: t, start: o, end: a }
  );
}
function _getEdge(t, e, i, n) {
  return t && e ? n(t[i], e[i]) : t ? t[i] : e ? e[i] : 0;
}
function _segments(t, e, i) {
  const n = t.segments,
    o = t.points,
    a = e.points,
    r = [];
  if (e._refPoints)
    for (let t = 0, e = a.length; t < e; ++t) {
      const e = a[t],
        i = e._prop;
      i && (e[i] = e._ref[i]);
    }
  for (let t = 0; t < n.length; t++) {
    const s = n[t],
      l = getBounds(i, o[s.start], o[s.end], s.loop);
    if (!e.segments) {
      r.push({ source: s, target: l, start: o[s.start], end: o[s.end] });
      continue;
    }
    const c = _boundSegments(e, l);
    for (let t = 0; t < c.length; ++t) {
      const e = c[t],
        n = getBounds(i, a[e.start], a[e.end], e.loop),
        d = _boundSegment(s, o, n);
      for (let t = 0; t < d.length; t++)
        r.push({
          source: d[t],
          target: e,
          start: { [i]: _getEdge(l, n, 'start', Math.max) },
          end: { [i]: _getEdge(l, n, 'end', Math.min) },
        });
    }
  }
  return r;
}
function clipBounds(t, e, i) {
  const { top: n, bottom: o } = e.chart.chartArea,
    { property: a, start: r, end: s } = i || {};
  'x' === a && (t.beginPath(), t.rect(r, n, s - r, o - n), t.clip());
}
function interpolatedLineTo(t, e, i, n) {
  const o = e.interpolate(i, n);
  o && t.lineTo(o.x, o.y);
}
function _fill(t, e) {
  const { line: i, target: n, property: o, color: a, scale: r } = e,
    s = _segments(e.line, e.target, o);
  t.fillStyle = a;
  for (let e = 0, a = s.length; e < a; ++e) {
    const { source: a, target: l, start: c, end: d } = s[e];
    t.save(), clipBounds(t, r, getBounds(o, c, d)), t.beginPath();
    const h = !!i.pathSegment(t, a);
    h ? t.closePath() : interpolatedLineTo(t, n, d, o);
    const u = !!n.pathSegment(t, l, { move: h, reverse: !0 }),
      g = h && u;
    g || interpolatedLineTo(t, n, c, o),
      t.closePath(),
      t.fill(g ? 'evenodd' : 'nonzero'),
      t.restore();
  }
}
function doFill(t, e) {
  const { line: i, target: n, above: o, below: a, area: r, scale: s } = e,
    l = i._loop ? 'angle' : 'x';
  t.save(),
    'x' === l &&
      a !== o &&
      (_clip(t, n, r.top),
      _fill(t, { line: i, target: n, color: o, scale: s, property: l }),
      t.restore(),
      t.save(),
      _clip(t, n, r.bottom)),
    _fill(t, { line: i, target: n, color: a, scale: s, property: l }),
    t.restore();
}
var plugin_filler = {
  id: 'filler',
  afterDatasetsUpdate(t, e) {
    const i = (t.data.datasets || []).length,
      n = e.propagate,
      o = [];
    let a, r, s, l;
    for (r = 0; r < i; ++r)
      (l = null),
        (s = (a = t.getDatasetMeta(r)).dataset) &&
          s.options &&
          s instanceof Line &&
          (l = {
            visible: t.isDatasetVisible(r),
            fill: decodeFill(s, r, i),
            chart: t,
            scale: a.vScale,
            line: s,
            target: void 0,
          }),
        (a.$filler = l),
        o.push(l);
    for (r = 0; r < i; ++r)
      (l = o[r]) &&
        !1 !== l.fill &&
        ((l.fill = resolveTarget(o, r, n)),
        (l.target = !1 !== l.fill && getTarget(l)));
  },
  beforeDatasetsDraw(t) {
    const e = t.getSortedVisibleDatasetMetas(),
      i = t.chartArea;
    let n, o;
    for (n = e.length - 1; n >= 0; --n)
      (o = e[n].$filler) && o.line.updateControlPoints(i);
  },
  beforeDatasetDraw(t, e) {
    const i = t.chartArea,
      n = t.ctx,
      o = e.meta.$filler;
    if (!o || !1 === o.fill) return;
    const { line: a, target: r, scale: s } = o,
      l = a.options,
      c = l.fill,
      d = l.backgroundColor || defaults.color,
      { above: h = d, below: u = d } = c || {};
    r &&
      a.points.length &&
      (clipArea(n, i),
      doFill(n, { line: a, target: r, above: h, below: u, area: i, scale: s }),
      unclipArea(n));
  },
};
function getBoxWidth(t, e) {
  const { boxWidth: i } = t;
  return (t.usePointStyle && i > e) || isNullOrUndef(i) ? e : i;
}
function getBoxHeight(t, e) {
  const { boxHeight: i } = t;
  return (t.usePointStyle && i > e) || isNullOrUndef(i) ? e : i;
}
defaults.set('legend', {
  display: !0,
  position: 'top',
  align: 'center',
  fullWidth: !0,
  reverse: !1,
  weight: 1e3,
  onClick(t, e, i) {
    const n = e.datasetIndex,
      o = i.chart;
    o.isDatasetVisible(n)
      ? (o.hide(n), (e.hidden = !0))
      : (o.show(n), (e.hidden = !1));
  },
  onHover: null,
  onLeave: null,
  labels: {
    boxWidth: 40,
    padding: 10,
    generateLabels(t) {
      const e = t.data.datasets,
        i = t.options.legend || {},
        n = i.labels && i.labels.usePointStyle;
      return t._getSortedDatasetMetas().map((t) => {
        const i = t.controller.getStyle(n ? 0 : void 0);
        return {
          text: e[t.index].label,
          fillStyle: i.backgroundColor,
          hidden: !t.visible,
          lineCap: i.borderCapStyle,
          lineDash: i.borderDash,
          lineDashOffset: i.borderDashOffset,
          lineJoin: i.borderJoinStyle,
          lineWidth: i.borderWidth,
          strokeStyle: i.borderColor,
          pointStyle: i.pointStyle,
          rotation: i.rotation,
          datasetIndex: t.index,
        };
      }, this);
    },
  },
  title: { display: !1, position: 'center', text: '' },
});
class Legend extends Element {
  constructor(t) {
    super(),
      Object.assign(this, t),
      (this.legendHitBoxes = []),
      (this._hoveredItem = null),
      (this.doughnutMode = !1),
      (this.chart = t.chart),
      (this.options = t.options),
      (this.ctx = t.ctx),
      (this.legendItems = void 0),
      (this.columnWidths = void 0),
      (this.columnHeights = void 0),
      (this.lineWidths = void 0),
      (this._minSize = void 0),
      (this.maxHeight = void 0),
      (this.maxWidth = void 0),
      (this.top = void 0),
      (this.bottom = void 0),
      (this.left = void 0),
      (this.right = void 0),
      (this.height = void 0),
      (this.width = void 0),
      (this._margins = void 0),
      (this.paddingTop = void 0),
      (this.paddingBottom = void 0),
      (this.paddingLeft = void 0),
      (this.paddingRight = void 0),
      (this.position = void 0),
      (this.weight = void 0),
      (this.fullWidth = void 0);
  }
  beforeUpdate() {}
  update(t, e, i) {
    const n = this;
    n.beforeUpdate(),
      (n.maxWidth = t),
      (n.maxHeight = e),
      (n._margins = i),
      n.beforeSetDimensions(),
      n.setDimensions(),
      n.afterSetDimensions(),
      n.beforeBuildLabels(),
      n.buildLabels(),
      n.afterBuildLabels(),
      n.beforeFit(),
      n.fit(),
      n.afterFit(),
      n.afterUpdate();
  }
  afterUpdate() {}
  beforeSetDimensions() {}
  setDimensions() {
    const t = this;
    t.isHorizontal()
      ? ((t.width = t.maxWidth), (t.left = 0), (t.right = t.width))
      : ((t.height = t.maxHeight), (t.top = 0), (t.bottom = t.height)),
      (t.paddingLeft = 0),
      (t.paddingTop = 0),
      (t.paddingRight = 0),
      (t.paddingBottom = 0),
      (t._minSize = { width: 0, height: 0 });
  }
  afterSetDimensions() {}
  beforeBuildLabels() {}
  buildLabels() {
    const t = this,
      e = t.options.labels || {};
    let i = callback(e.generateLabels, [t.chart], t) || [];
    e.filter && (i = i.filter((i) => e.filter(i, t.chart.data))),
      t.options.reverse && i.reverse(),
      (t.legendItems = i);
  }
  afterBuildLabels() {}
  beforeFit() {}
  fit() {
    const t = this,
      e = t.options,
      i = e.labels,
      n = e.display,
      o = t.ctx,
      a = toFont(i.font),
      r = a.size,
      s = getBoxWidth(i, r),
      l = getBoxHeight(i, r),
      c = Math.max(l, r),
      d = (t.legendHitBoxes = []),
      h = t._minSize,
      u = t.isHorizontal(),
      g = t._computeTitleHeight();
    if (
      (u
        ? ((h.width = t.maxWidth), (h.height = n ? 10 : 0))
        : ((h.width = n ? 10 : 0), (h.height = t.maxHeight)),
      n)
    ) {
      if (((o.font = a.string), u)) {
        const e = (t.lineWidths = [0]);
        let n = g;
        (o.textAlign = 'left'),
          (o.textBaseline = 'middle'),
          t.legendItems.forEach((t, a) => {
            const l = s + r / 2 + o.measureText(t.text).width;
            (0 === a || e[e.length - 1] + l + 2 * i.padding > h.width) &&
              ((n += c + i.padding), (e[e.length - (a > 0 ? 0 : 1)] = 0)),
              (d[a] = { left: 0, top: 0, width: l, height: c }),
              (e[e.length - 1] += l + i.padding);
          }),
          (h.height += n);
      } else {
        const e = i.padding,
          n = (t.columnWidths = []),
          a = (t.columnHeights = []);
        let l = i.padding,
          u = 0,
          p = 0;
        const f = h.height - g;
        t.legendItems.forEach((t, h) => {
          const g = s + r / 2 + o.measureText(t.text).width;
          h > 0 &&
            p + r + 2 * e > f &&
            ((l += u + i.padding), n.push(u), a.push(p), (u = 0), (p = 0)),
            (u = Math.max(u, g)),
            (p += r + e),
            (d[h] = { left: 0, top: 0, width: g, height: c });
        }),
          (l += u),
          n.push(u),
          a.push(p),
          (h.width += l);
      }
      (t.width = h.width), (t.height = h.height);
    } else t.width = h.width = t.height = h.height = 0;
  }
  afterFit() {}
  isHorizontal() {
    return (
      'top' === this.options.position || 'bottom' === this.options.position
    );
  }
  draw() {
    const t = this,
      e = t.options,
      i = e.labels,
      n = defaults.color,
      o = defaults.elements.line,
      a = t.height,
      r = t.columnHeights,
      s = t.width,
      l = t.lineWidths;
    if (!e.display) return;
    t.drawTitle();
    const c = getRtlAdapter(e.rtl, t.left, t._minSize.width),
      d = t.ctx,
      h = toFont(i.font),
      u = h.color,
      g = h.size;
    let p;
    (d.textAlign = c.textAlign('left')),
      (d.textBaseline = 'middle'),
      (d.lineWidth = 0.5),
      (d.strokeStyle = u),
      (d.fillStyle = u),
      (d.font = h.string);
    const f = getBoxWidth(i, g),
      m = getBoxHeight(i, g),
      b = Math.max(g, m),
      x = t.legendHitBoxes,
      _ = function (t, n) {
        switch (e.align) {
          case 'start':
            return i.padding;
          case 'end':
            return t - n;
          default:
            return (t - n + i.padding) / 2;
        }
      },
      y = t.isHorizontal(),
      v = this._computeTitleHeight();
    (p = y
      ? { x: t.left + _(s, l[0]), y: t.top + i.padding + v, line: 0 }
      : { x: t.left + i.padding, y: t.top + _(a, r[0]) + v, line: 0 }),
      overrideTextDirection(t.ctx, e.textDirection);
    const M = b + i.padding;
    t.legendItems.forEach((e, h) => {
      const u = d.measureText(e.text).width,
        v = f + g / 2 + u;
      let P = p.x,
        S = p.y;
      c.setWidth(t._minSize.width),
        y
          ? h > 0 &&
            P + v + i.padding > t.left + t._minSize.width &&
            ((S = p.y += M), p.line++, (P = p.x = t.left + _(s, l[p.line])))
          : h > 0 &&
            S + M > t.top + t._minSize.height &&
            ((P = p.x = P + t.columnWidths[p.line] + i.padding),
            p.line++,
            (S = p.y = t.top + _(a, r[p.line])));
      const k = c.x(P);
      !(function (t, e, a) {
        if (isNaN(f) || f <= 0 || isNaN(m) || m < 0) return;
        d.save();
        const r = valueOrDefault(a.lineWidth, o.borderWidth);
        if (
          ((d.fillStyle = valueOrDefault(a.fillStyle, n)),
          (d.lineCap = valueOrDefault(a.lineCap, o.borderCapStyle)),
          (d.lineDashOffset = valueOrDefault(
            a.lineDashOffset,
            o.borderDashOffset,
          )),
          (d.lineJoin = valueOrDefault(a.lineJoin, o.borderJoinStyle)),
          (d.lineWidth = r),
          (d.strokeStyle = valueOrDefault(a.strokeStyle, n)),
          d.setLineDash &&
            d.setLineDash(valueOrDefault(a.lineDash, o.borderDash)),
          i && i.usePointStyle)
        ) {
          const i = {
              radius: (f * Math.SQRT2) / 2,
              pointStyle: a.pointStyle,
              rotation: a.rotation,
              borderWidth: r,
            },
            n = c.xPlus(t, f / 2);
          drawPoint(d, i, n, e + g / 2);
        } else {
          const i = e + Math.max((g - m) / 2, 0);
          d.fillRect(c.leftForLtr(t, f), i, f, m),
            0 !== r && d.strokeRect(c.leftForLtr(t, f), i, f, m);
        }
        d.restore();
      })(k, S, e),
        (x[h].left = c.leftForLtr(k, x[h].width)),
        (x[h].top = S),
        (function (t, e, i, n) {
          const o = g / 2,
            a = c.xPlus(t, f + o),
            r = e + b / 2;
          d.fillText(i.text, a, r),
            i.hidden &&
              (d.beginPath(),
              (d.lineWidth = 2),
              d.moveTo(a, r),
              d.lineTo(c.xPlus(a, n), r),
              d.stroke());
        })(k, S, e, u),
        y ? (p.x += v + i.padding) : (p.y += M);
    }),
      restoreTextDirection(t.ctx, e.textDirection);
  }
  drawTitle() {
    const t = this,
      e = t.options,
      i = e.title,
      n = toFont(i.font),
      o = toPadding(i.padding);
    if (!i.display) return;
    const a = getRtlAdapter(e.rtl, t.left, t._minSize.width),
      r = t.ctx,
      s = i.position;
    let l, c;
    const d = n.size / 2;
    let h = t.top + o.top + d,
      u = t.left,
      g = t.width;
    if (this.isHorizontal())
      switch (((g = Math.max(...t.lineWidths)), e.align)) {
        case 'start':
          break;
        case 'end':
          u = t.right - g;
          break;
        default:
          u = (t.left + t.right) / 2 - g / 2;
      }
    else {
      const i = Math.max(...t.columnHeights);
      switch (e.align) {
        case 'start':
          break;
        case 'end':
          h += t.height - i;
          break;
        default:
          h += (t.height - i) / 2;
      }
    }
    switch (s) {
      case 'start':
        (l = u), (c = 'left');
        break;
      case 'end':
        (l = u + g), (c = 'right');
        break;
      default:
        (l = u + g / 2), (c = 'center');
    }
    (r.textAlign = a.textAlign(c)),
      (r.textBaseline = 'middle'),
      (r.strokeStyle = n.color),
      (r.fillStyle = n.color),
      (r.font = n.string),
      r.fillText(i.text, l, h);
  }
  _computeTitleHeight() {
    const t = this.options.title,
      e = toFont(t.font),
      i = toPadding(t.padding);
    return t.display ? e.lineHeight + i.height : 0;
  }
  _getLegendItemAt(t, e) {
    const i = this;
    let n, o, a;
    if (t >= i.left && t <= i.right && e >= i.top && e <= i.bottom)
      for (a = i.legendHitBoxes, n = 0; n < a.length; ++n)
        if (
          t >= (o = a[n]).left &&
          t <= o.left + o.width &&
          e >= o.top &&
          e <= o.top + o.height
        )
          return i.legendItems[n];
    return null;
  }
  handleEvent(t) {
    const e = this,
      i = e.options,
      n = 'mouseup' === t.type ? 'click' : t.type;
    if ('mousemove' === n) {
      if (!i.onHover && !i.onLeave) return;
    } else {
      if ('click' !== n) return;
      if (!i.onClick) return;
    }
    const o = e._getLegendItemAt(t.x, t.y);
    'click' === n
      ? o && callback(i.onClick, [t, o, e], e)
      : (i.onLeave &&
          o !== e._hoveredItem &&
          (e._hoveredItem && callback(i.onLeave, [t, e._hoveredItem, e], e),
          (e._hoveredItem = o)),
        o && callback(i.onHover, [t, o, e], e));
  }
}
function createNewLegendAndAttach(t, e) {
  const i = new Legend({ ctx: t.ctx, options: e, chart: t });
  layouts.configure(t, i, e), layouts.addBox(t, i), (t.legend = i);
}
var plugin_legend = {
  id: 'legend',
  _element: Legend,
  beforeInit(t) {
    const e = t.options.legend;
    e && createNewLegendAndAttach(t, e);
  },
  afterUpdate(t) {
    const e = t.options.legend,
      i = t.legend;
    e
      ? (mergeIf(e, defaults.legend),
        i
          ? (layouts.configure(t, i, e), (i.options = e), i.buildLabels())
          : createNewLegendAndAttach(t, e))
      : i && (layouts.removeBox(t, i), delete t.legend);
  },
  afterEvent(t, e) {
    const i = t.legend;
    i && i.handleEvent(e);
  },
};
defaults.set('title', {
  align: 'center',
  display: !1,
  font: { style: 'bold' },
  fullWidth: !0,
  padding: 10,
  position: 'top',
  text: '',
  weight: 2e3,
});
class Title extends Element {
  constructor(t) {
    super(),
      Object.assign(this, t),
      (this.chart = t.chart),
      (this.options = t.options),
      (this.ctx = t.ctx),
      (this._margins = void 0),
      (this._padding = void 0),
      (this.legendHitBoxes = []),
      (this.top = void 0),
      (this.bottom = void 0),
      (this.left = void 0),
      (this.right = void 0),
      (this.width = void 0),
      (this.height = void 0),
      (this.maxWidth = void 0),
      (this.maxHeight = void 0),
      (this.position = void 0),
      (this.weight = void 0),
      (this.fullWidth = void 0);
  }
  beforeUpdate() {}
  update(t, e, i) {
    const n = this;
    n.beforeUpdate(),
      (n.maxWidth = t),
      (n.maxHeight = e),
      (n._margins = i),
      n.beforeSetDimensions(),
      n.setDimensions(),
      n.afterSetDimensions(),
      n.beforeBuildLabels(),
      n.buildLabels(),
      n.afterBuildLabels(),
      n.beforeFit(),
      n.fit(),
      n.afterFit(),
      n.afterUpdate();
  }
  afterUpdate() {}
  beforeSetDimensions() {}
  setDimensions() {
    const t = this;
    t.isHorizontal()
      ? ((t.width = t.maxWidth), (t.left = 0), (t.right = t.width))
      : ((t.height = t.maxHeight), (t.top = 0), (t.bottom = t.height));
  }
  afterSetDimensions() {}
  beforeBuildLabels() {}
  buildLabels() {}
  afterBuildLabels() {}
  beforeFit() {}
  fit() {
    const t = this,
      e = t.options,
      i = {},
      n = t.isHorizontal();
    if (!e.display) return void (t.width = i.width = t.height = i.height = 0);
    const o = isArray(e.text) ? e.text.length : 1;
    t._padding = toPadding(e.padding);
    const a = o * toFont(e.font).lineHeight + t._padding.height;
    (t.width = i.width = n ? t.maxWidth : a),
      (t.height = i.height = n ? a : t.maxHeight);
  }
  afterFit() {}
  isHorizontal() {
    const t = this.options.position;
    return 'top' === t || 'bottom' === t;
  }
  draw() {
    const t = this,
      e = t.ctx,
      i = t.options;
    if (!i.display) return;
    const n = toFont(i.font),
      o = n.lineHeight,
      a = o / 2 + t._padding.top;
    let r = 0;
    const s = t.top,
      l = t.left,
      c = t.bottom,
      d = t.right;
    let h, u, g, p;
    if (t.isHorizontal()) {
      switch (i.align) {
        case 'start':
          (u = l), (p = 'left');
          break;
        case 'end':
          (u = d), (p = 'right');
          break;
        default:
          (u = l + (d - l) / 2), (p = 'center');
      }
      (g = s + a), (h = d - l);
    } else {
      switch (((u = 'left' === i.position ? l + a : d - a), i.align)) {
        case 'start':
          (g = 'left' === i.position ? c : s), (p = 'left');
          break;
        case 'end':
          (g = 'left' === i.position ? s : c), (p = 'right');
          break;
        default:
          (g = s + (c - s) / 2), (p = 'center');
      }
      (h = c - s), (r = Math.PI * ('left' === i.position ? -0.5 : 0.5));
    }
    e.save(),
      (e.fillStyle = n.color),
      (e.font = n.string),
      e.translate(u, g),
      e.rotate(r),
      (e.textAlign = p),
      (e.textBaseline = 'middle');
    const f = i.text;
    if (isArray(f)) {
      let t = 0;
      for (let i = 0; i < f.length; ++i) e.fillText(f[i], 0, t, h), (t += o);
    } else e.fillText(f, 0, 0, h);
    e.restore();
  }
}
function createNewTitleBlockAndAttach(t, e) {
  const i = new Title({ ctx: t.ctx, options: e, chart: t });
  layouts.configure(t, i, e), layouts.addBox(t, i), (t.titleBlock = i);
}
var plugin_title = {
  id: 'title',
  _element: Title,
  beforeInit(t) {
    const e = t.options.title;
    e && createNewTitleBlockAndAttach(t, e);
  },
  beforeUpdate(t) {
    const e = t.options.title,
      i = t.titleBlock;
    e
      ? (mergeIf(e, defaults.title),
        i
          ? (layouts.configure(t, i, e), (i.options = e))
          : createNewTitleBlockAndAttach(t, e))
      : i && (layouts.removeBox(t, i), delete t.titleBlock);
  },
};
defaults.set('tooltips', {
  enabled: !0,
  custom: null,
  mode: 'nearest',
  position: 'average',
  intersect: !0,
  backgroundColor: 'rgba(0,0,0,0.8)',
  titleFont: { style: 'bold', color: '#fff' },
  titleSpacing: 2,
  titleMarginBottom: 6,
  titleAlign: 'left',
  bodySpacing: 2,
  bodyFont: { color: '#fff' },
  bodyAlign: 'left',
  footerSpacing: 2,
  footerMarginTop: 6,
  footerFont: { color: '#fff', style: 'bold' },
  footerAlign: 'left',
  yPadding: 6,
  xPadding: 6,
  caretPadding: 2,
  caretSize: 5,
  cornerRadius: 6,
  multiKeyBackground: '#fff',
  displayColors: !0,
  borderColor: 'rgba(0,0,0,0)',
  borderWidth: 0,
  animation: {
    duration: 400,
    easing: 'easeOutQuart',
    numbers: {
      type: 'number',
      properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],
    },
    opacity: { easing: 'linear', duration: 200 },
  },
  callbacks: {
    beforeTitle: noop,
    title(t, e) {
      let i = '';
      const n = e.labels,
        o = n ? n.length : 0;
      if (t.length > 0) {
        const e = t[0];
        e.label ? (i = e.label) : o > 0 && e.index < o && (i = n[e.index]);
      }
      return i;
    },
    afterTitle: noop,
    beforeBody: noop,
    beforeLabel: noop,
    label(t, e) {
      let i = e.datasets[t.datasetIndex].label || '';
      i && (i += ': ');
      const n = t.value;
      return isNullOrUndef(n) || (i += n), i;
    },
    labelColor(t, e) {
      const i = e.getDatasetMeta(t.datasetIndex).controller.getStyle(t.index);
      return { borderColor: i.borderColor, backgroundColor: i.backgroundColor };
    },
    labelTextColor() {
      return this.options.bodyFont.color;
    },
    afterLabel: noop,
    afterBody: noop,
    beforeFooter: noop,
    footer: noop,
    afterFooter: noop,
  },
});
const positioners = {
  average(t) {
    if (!t.length) return !1;
    let e,
      i,
      n = 0,
      o = 0,
      a = 0;
    for (e = 0, i = t.length; e < i; ++e) {
      const i = t[e].element;
      if (i && i.hasValue()) {
        const t = i.tooltipPosition();
        (n += t.x), (o += t.y), ++a;
      }
    }
    return { x: n / a, y: o / a };
  },
  nearest(t, e) {
    let i,
      n,
      o,
      a = e.x,
      r = e.y,
      s = Number.POSITIVE_INFINITY;
    for (i = 0, n = t.length; i < n; ++i) {
      const n = t[i].element;
      if (n && n.hasValue()) {
        const t = distanceBetweenPoints(e, n.getCenterPoint());
        t < s && ((s = t), (o = n));
      }
    }
    if (o) {
      const t = o.tooltipPosition();
      (a = t.x), (r = t.y);
    }
    return { x: a, y: r };
  },
};
function pushOrConcat(t, e) {
  return e && (isArray(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t;
}
function splitNewlines(t) {
  return ('string' == typeof t || t instanceof String) && t.indexOf('\n') > -1
    ? t.split('\n')
    : t;
}
function createTooltipItem(t, e) {
  const { datasetIndex: i, index: n } = e,
    { label: o, value: a } = t.getDatasetMeta(i).controller.getLabelAndValue(n);
  return { label: o, value: a, index: n, datasetIndex: i };
}
function resolveOptions(t) {
  return (
    ((t = Object.assign({}, defaults.tooltips, t)).bodyFont = toFont(
      t.bodyFont,
    )),
    (t.titleFont = toFont(t.titleFont)),
    (t.footerFont = toFont(t.footerFont)),
    (t.boxHeight = valueOrDefault(t.boxHeight, t.bodyFont.size)),
    (t.boxWidth = valueOrDefault(t.boxWidth, t.bodyFont.size)),
    t
  );
}
function getTooltipSize(t) {
  const e = t._chart.ctx,
    { body: i, footer: n, options: o, title: a } = t,
    { bodyFont: r, footerFont: s, titleFont: l, boxWidth: c, boxHeight: d } = o,
    h = a.length,
    u = n.length,
    g = i.length;
  let p = 2 * o.yPadding,
    f = 0,
    m = i.reduce(
      (t, e) => t + e.before.length + e.lines.length + e.after.length,
      0,
    );
  if (
    ((m += t.beforeBody.length + t.afterBody.length),
    h && (p += h * l.size + (h - 1) * o.titleSpacing + o.titleMarginBottom),
    m)
  ) {
    p +=
      g * (o.displayColors ? Math.max(d, r.size) : r.size) +
      (m - g) * r.size +
      (m - 1) * o.bodySpacing;
  }
  u && (p += o.footerMarginTop + u * s.size + (u - 1) * o.footerSpacing);
  let b = 0;
  const x = function (t) {
    f = Math.max(f, e.measureText(t).width + b);
  };
  return (
    e.save(),
    (e.font = l.string),
    each(t.title, x),
    (e.font = r.string),
    each(t.beforeBody.concat(t.afterBody), x),
    (b = o.displayColors ? c + 2 : 0),
    each(i, (t) => {
      each(t.before, x), each(t.lines, x), each(t.after, x);
    }),
    (b = 0),
    (e.font = s.string),
    each(t.footer, x),
    e.restore(),
    { width: (f += 2 * o.xPadding), height: p }
  );
}
function determineAlignment(t, e, i) {
  const { x: n, y: o, width: a, height: r } = i,
    s = t.chartArea;
  let l,
    c,
    d = 'center',
    h = 'center';
  o < r ? (h = 'top') : o > t.height - r && (h = 'bottom');
  const u = (s.left + s.right) / 2,
    g = (s.top + s.bottom) / 2;
  'center' === h
    ? ((l = (t) => t <= u), (c = (t) => t > u))
    : ((l = (t) => t <= a / 2), (c = (e) => e >= t.width - a / 2));
  const p = (t) => (t <= g ? 'top' : 'bottom');
  return (
    l(n)
      ? ((d = 'left'),
        ((i) => i + a + e.caretSize + e.caretPadding > t.width)(n) &&
          ((d = 'center'), (h = p(o))))
      : c(n) &&
        ((d = 'right'),
        ((t) => t - a - e.caretSize - e.caretPadding < 0)(n) &&
          ((d = 'center'), (h = p(o)))),
    { xAlign: e.xAlign ? e.xAlign : d, yAlign: e.yAlign ? e.yAlign : h }
  );
}
function alignX(t, e, i) {
  let { x: n, width: o } = t;
  return (
    'right' === e
      ? (n -= o)
      : 'center' === e &&
        ((n -= o / 2) + o > i && (n = i - o), n < 0 && (n = 0)),
    n
  );
}
function alignY(t, e, i) {
  let { y: n, height: o } = t;
  return 'top' === e ? (n += i) : (n -= 'bottom' === e ? o + i : o / 2), n;
}
function getBackgroundPoint(t, e, i, n) {
  const { caretSize: o, caretPadding: a, cornerRadius: r } = t,
    { xAlign: s, yAlign: l } = i,
    c = o + a,
    d = r + a;
  let h = alignX(e, s, n.width);
  return (
    'center' === l
      ? 'left' === s
        ? (h += c)
        : 'right' === s && (h -= c)
      : 'left' === s
      ? (h -= d)
      : 'right' === s && (h += d),
    { x: h, y: alignY(e, l, c) }
  );
}
function getAlignedX(t, e) {
  const i = t.options;
  return 'center' === e
    ? t.x + t.width / 2
    : 'right' === e
    ? t.x + t.width - i.xPadding
    : t.x + i.xPadding;
}
function getBeforeAfterBodyLines(t) {
  return pushOrConcat([], splitNewlines(t));
}
class Tooltip extends Element {
  constructor(t) {
    super(),
      (this.opacity = 0),
      (this._active = []),
      (this._chart = t._chart),
      (this._eventPosition = void 0),
      (this._size = void 0),
      (this._cachedAnimations = void 0),
      (this.$animations = void 0),
      (this.options = void 0),
      (this.dataPoints = void 0),
      (this.title = void 0),
      (this.beforeBody = void 0),
      (this.body = void 0),
      (this.afterBody = void 0),
      (this.footer = void 0),
      (this.xAlign = void 0),
      (this.yAlign = void 0),
      (this.x = void 0),
      (this.y = void 0),
      (this.height = void 0),
      (this.width = void 0),
      (this.caretX = void 0),
      (this.caretY = void 0),
      (this.labelColors = void 0),
      (this.labelTextColors = void 0),
      this.initialize();
  }
  initialize() {
    this.options = resolveOptions(this._chart.options.tooltips);
  }
  _resolveAnimations() {
    const t = this,
      e = t._cachedAnimations;
    if (e) return e;
    const i = t._chart.options.animation && t.options.animation,
      n = new Animations(t._chart, i);
    return (t._cachedAnimations = Object.freeze(n)), n;
  }
  getTitle(t, e) {
    const i = this.options.callbacks,
      n = i.beforeTitle.apply(this, [t, e]),
      o = i.title.apply(this, [t, e]),
      a = i.afterTitle.apply(this, [t, e]);
    let r = [];
    return (
      (r = pushOrConcat(r, splitNewlines(n))),
      (r = pushOrConcat(r, splitNewlines(o))),
      (r = pushOrConcat(r, splitNewlines(a)))
    );
  }
  getBeforeBody(t, e) {
    return getBeforeAfterBodyLines(
      this.options.callbacks.beforeBody.apply(this, [t, e]),
    );
  }
  getBody(t, e) {
    const i = this,
      n = i.options.callbacks,
      o = [];
    return (
      each(t, (t) => {
        const a = { before: [], lines: [], after: [] };
        pushOrConcat(a.before, splitNewlines(n.beforeLabel.call(i, t, e))),
          pushOrConcat(a.lines, n.label.call(i, t, e)),
          pushOrConcat(a.after, splitNewlines(n.afterLabel.call(i, t, e))),
          o.push(a);
      }),
      o
    );
  }
  getAfterBody(t, e) {
    return getBeforeAfterBodyLines(
      this.options.callbacks.afterBody.apply(this, [t, e]),
    );
  }
  getFooter(t, e) {
    const i = this.options.callbacks,
      n = i.beforeFooter.apply(this, [t, e]),
      o = i.footer.apply(this, [t, e]),
      a = i.afterFooter.apply(this, [t, e]);
    let r = [];
    return (
      (r = pushOrConcat(r, splitNewlines(n))),
      (r = pushOrConcat(r, splitNewlines(o))),
      (r = pushOrConcat(r, splitNewlines(a)))
    );
  }
  _createItems() {
    const t = this,
      e = t._active,
      i = t.options,
      n = t._chart.data,
      o = [],
      a = [];
    let r,
      s,
      l = [];
    for (r = 0, s = e.length; r < s; ++r)
      l.push(createTooltipItem(t._chart, e[r]));
    return (
      i.filter && (l = l.filter((t) => i.filter(t, n))),
      i.itemSort && (l = l.sort((t, e) => i.itemSort(t, e, n))),
      each(l, (e) => {
        o.push(i.callbacks.labelColor.call(t, e, t._chart)),
          a.push(i.callbacks.labelTextColor.call(t, e, t._chart));
      }),
      (t.labelColors = o),
      (t.labelTextColors = a),
      (t.dataPoints = l),
      l
    );
  }
  update(t) {
    const e = this,
      i = e.options,
      n = e._active;
    let o;
    if (n.length) {
      const t = e._chart.data,
        a = positioners[i.position].call(e, n, e._eventPosition),
        r = e._createItems();
      (e.title = e.getTitle(r, t)),
        (e.beforeBody = e.getBeforeBody(r, t)),
        (e.body = e.getBody(r, t)),
        (e.afterBody = e.getAfterBody(r, t)),
        (e.footer = e.getFooter(r, t));
      const s = (e._size = getTooltipSize(e)),
        l = Object.assign({}, a, s),
        c = determineAlignment(e._chart, i, l),
        d = getBackgroundPoint(i, l, c, e._chart);
      (e.xAlign = c.xAlign),
        (e.yAlign = c.yAlign),
        (o = {
          opacity: 1,
          x: d.x,
          y: d.y,
          width: s.width,
          height: s.height,
          caretX: a.x,
          caretY: a.y,
        });
    } else 0 !== e.opacity && (o = { opacity: 0 });
    o && e._resolveAnimations().update(e, o), t && i.custom && i.custom.call(e);
  }
  drawCaret(t, e, i) {
    const n = this.getCaretPosition(t, i);
    e.lineTo(n.x1, n.y1), e.lineTo(n.x2, n.y2), e.lineTo(n.x3, n.y3);
  }
  getCaretPosition(t, e) {
    const { xAlign: i, yAlign: n, options: o } = this,
      { cornerRadius: a, caretSize: r } = o,
      { x: s, y: l } = t,
      { width: c, height: d } = e;
    let h, u, g, p, f, m;
    return (
      'center' === n
        ? ((u = 'left' === i ? (h = s) - r : (h = s + c) + r),
          (g = h),
          (p = (f = l + d / 2) + r),
          (m = f - r))
        : ((h =
            (u =
              'left' === i
                ? s + a + r
                : 'right' === i
                ? s + c - a - r
                : this.caretX) - r),
          (g = u + r),
          (f = 'top' === n ? (p = l) - r : (p = l + d) + r),
          (m = p)),
      { x1: h, x2: u, x3: g, y1: p, y2: f, y3: m }
    );
  }
  drawTitle(t, e) {
    const i = this,
      n = i.options,
      o = i.title,
      a = o.length;
    let r, s, l;
    if (a) {
      const c = getRtlAdapter(n.rtl, i.x, i.width);
      for (
        t.x = getAlignedX(i, n.titleAlign),
          e.textAlign = c.textAlign(n.titleAlign),
          e.textBaseline = 'middle',
          r = n.titleFont,
          s = n.titleSpacing,
          e.fillStyle = n.titleFont.color,
          e.font = r.string,
          l = 0;
        l < a;
        ++l
      )
        e.fillText(o[l], c.x(t.x), t.y + r.size / 2),
          (t.y += r.size + s),
          l + 1 === a && (t.y += n.titleMarginBottom - s);
    }
  }
  _drawColorBox(t, e, i, n) {
    const o = this.options,
      a = this.labelColors[i],
      { boxHeight: r, boxWidth: s, bodyFont: l } = o,
      c = getAlignedX(this, 'left'),
      d = n.x(c),
      h = r < l.size ? (l.size - r) / 2 : 0,
      u = e.y + h;
    (t.fillStyle = o.multiKeyBackground),
      t.fillRect(n.leftForLtr(d, s), u, s, r),
      (t.lineWidth = 1),
      (t.strokeStyle = a.borderColor),
      t.strokeRect(n.leftForLtr(d, s), u, s, r),
      (t.fillStyle = a.backgroundColor),
      t.fillRect(n.leftForLtr(n.xPlus(d, 1), s - 2), u + 1, s - 2, r - 2),
      (t.fillStyle = this.labelTextColors[i]);
  }
  drawBody(t, e) {
    const i = this,
      { body: n, options: o } = i,
      {
        bodyFont: a,
        bodySpacing: r,
        bodyAlign: s,
        displayColors: l,
        boxHeight: c,
        boxWidth: d,
      } = o;
    let h = a.size,
      u = 0;
    const g = getRtlAdapter(o.rtl, i.x, i.width),
      p = function (i) {
        e.fillText(i, g.x(t.x + u), t.y + h / 2), (t.y += h + r);
      },
      f = g.textAlign(s);
    let m, b, x, _, y, v, M;
    for (
      e.textAlign = s,
        e.textBaseline = 'middle',
        e.font = a.string,
        t.x = getAlignedX(i, f),
        e.fillStyle = a.color,
        each(i.beforeBody, p),
        u = l && 'right' !== f ? ('center' === s ? d / 2 + 1 : d + 2) : 0,
        _ = 0,
        v = n.length;
      _ < v;
      ++_
    ) {
      for (
        m = n[_],
          b = i.labelTextColors[_],
          e.fillStyle = b,
          each(m.before, p),
          x = m.lines,
          l &&
            x.length &&
            (i._drawColorBox(e, t, _, g), (h = Math.max(a.size, c))),
          y = 0,
          M = x.length;
        y < M;
        ++y
      )
        p(x[y]), (h = a.size);
      each(m.after, p);
    }
    (u = 0), (h = a.size), each(i.afterBody, p), (t.y -= r);
  }
  drawFooter(t, e) {
    const i = this,
      n = i.options,
      o = i.footer,
      a = o.length;
    let r, s;
    if (a) {
      const l = getRtlAdapter(n.rtl, i.x, i.width);
      for (
        t.x = getAlignedX(i, n.footerAlign),
          t.y += n.footerMarginTop,
          e.textAlign = l.textAlign(n.footerAlign),
          e.textBaseline = 'middle',
          r = n.footerFont,
          e.fillStyle = n.footerFont.color,
          e.font = r.string,
          s = 0;
        s < a;
        ++s
      )
        e.fillText(o[s], l.x(t.x), t.y + r.size / 2),
          (t.y += r.size + n.footerSpacing);
    }
  }
  drawBackground(t, e, i) {
    const { xAlign: n, yAlign: o, options: a } = this,
      { x: r, y: s } = t,
      { width: l, height: c } = i,
      d = a.cornerRadius;
    (e.fillStyle = a.backgroundColor),
      (e.strokeStyle = a.borderColor),
      (e.lineWidth = a.borderWidth),
      e.beginPath(),
      e.moveTo(r + d, s),
      'top' === o && this.drawCaret(t, e, i),
      e.lineTo(r + l - d, s),
      e.quadraticCurveTo(r + l, s, r + l, s + d),
      'center' === o && 'right' === n && this.drawCaret(t, e, i),
      e.lineTo(r + l, s + c - d),
      e.quadraticCurveTo(r + l, s + c, r + l - d, s + c),
      'bottom' === o && this.drawCaret(t, e, i),
      e.lineTo(r + d, s + c),
      e.quadraticCurveTo(r, s + c, r, s + c - d),
      'center' === o && 'left' === n && this.drawCaret(t, e, i),
      e.lineTo(r, s + d),
      e.quadraticCurveTo(r, s, r + d, s),
      e.closePath(),
      e.fill(),
      a.borderWidth > 0 && e.stroke();
  }
  _updateAnimationTarget() {
    const t = this,
      e = t._chart,
      i = t.options,
      n = t.$animations,
      o = n && n.x,
      a = n && n.y;
    if (o || a) {
      const n = positioners[i.position].call(t, t._active, t._eventPosition);
      if (!n) return;
      const r = (t._size = getTooltipSize(t)),
        s = Object.assign({}, n, t._size),
        l = determineAlignment(e, i, s),
        c = getBackgroundPoint(i, s, l, e);
      (o._to === c.x && a._to === c.y) ||
        ((t.xAlign = l.xAlign),
        (t.yAlign = l.yAlign),
        (t.width = r.width),
        (t.height = r.height),
        (t.caretX = n.x),
        (t.caretY = n.y),
        t._resolveAnimations().update(t, c));
    }
  }
  draw(t) {
    const e = this,
      i = e.options;
    let n = e.opacity;
    if (!n) return;
    e._updateAnimationTarget();
    const o = { width: e.width, height: e.height },
      a = { x: e.x, y: e.y };
    n = Math.abs(n) < 0.001 ? 0 : n;
    const r =
      e.title.length ||
      e.beforeBody.length ||
      e.body.length ||
      e.afterBody.length ||
      e.footer.length;
    i.enabled &&
      r &&
      (t.save(),
      (t.globalAlpha = n),
      e.drawBackground(a, t, o),
      overrideTextDirection(t, i.textDirection),
      (a.y += i.yPadding),
      e.drawTitle(a, t),
      e.drawBody(a, t),
      e.drawFooter(a, t),
      restoreTextDirection(t, i.textDirection),
      t.restore());
  }
  handleEvent(t, e) {
    const i = this,
      n = i.options,
      o = i._active || [];
    let a = !1,
      r = [];
    return (
      'mouseout' !== t.type &&
        ((r = i._chart.getElementsAtEventForMode(t, n.mode, n, e)),
        n.reverse && r.reverse()),
      (a = e || !_elementsEqual(r, o)) &&
        ((i._active = r),
        (n.enabled || n.custom) &&
          ((i._eventPosition = { x: t.x, y: t.y }), i.update(!0))),
      a
    );
  }
}
Tooltip.positioners = positioners;
var plugin_tooltip = {
    id: 'tooltip',
    _element: Tooltip,
    positioners: positioners,
    afterInit(t) {
      t.options.tooltips && (t.tooltip = new Tooltip({ _chart: t }));
    },
    beforeUpdate(t) {
      t.tooltip && t.tooltip.initialize();
    },
    reset(t) {
      t.tooltip && t.tooltip.initialize();
    },
    afterDraw(t) {
      const e = t.tooltip,
        i = { tooltip: e };
      !1 !== pluginsCore.notify(t, 'beforeTooltipDraw', [i]) &&
        (e && e.draw(t.ctx), pluginsCore.notify(t, 'afterTooltipDraw', [i]));
    },
    afterEvent(t, e, i) {
      if (t.tooltip) {
        const n = i;
        t.tooltip.handleEvent(e, n);
      }
    },
  },
  plugins = Object.freeze({
    __proto__: null,
    filler: plugin_filler,
    legend: plugin_legend,
    title: plugin_title,
    tooltip: plugin_tooltip,
  });
(Chart.helpers = helpers),
  (Chart._adapters = _adapters),
  (Chart.Animation = Animation),
  (Chart.animator = animator),
  (Chart.animationService = Animations),
  (Chart.controllers = controllers),
  (Chart.DatasetController = DatasetController),
  (Chart.defaults = defaults),
  (Chart.Element = Element),
  (Chart.elements = elements),
  (Chart.Interaction = Interaction),
  (Chart.layouts = layouts),
  (Chart.platforms = platforms),
  (Chart.plugins = pluginsCore),
  (Chart.Scale = Scale),
  (Chart.scaleService = scaleService),
  (Chart.Ticks = Ticks),
  Object.keys(scales).forEach((t) =>
    Chart.scaleService.registerScale(scales[t]),
  );
for (const t in plugins)
  Object.prototype.hasOwnProperty.call(plugins, t) &&
    Chart.plugins.register(plugins[t]);
'undefined' != typeof window && (window.Chart = Chart);
export default Chart;
